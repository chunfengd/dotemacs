#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :comments org

#+TITLE: Emacs Configuration File
#+AUTHOR: Chunfeng Dai

# Adapted from Lars Tveito's and Tianxiang Xiong's excellent
# configuration files.
# See:
#   - https://github.com/larstvei/dot-emacs/blob/master/init.org
#   - https://github.com/xiongtx/.emacs.d/blob/master/init.org

* Introduction
This is an Emacs configuration file written in Org-mode. It is adapted
from Lars Tveito's excellent [[https://github.com/larstvei/dot-emacs/blob/master/init.org][config file]] and Tianxiang Xiong's [[https://github.com/xiongtx/.emacs.d/blob/master/init.org][config]]
on GitHub.
* Dotemacs Path
** Define =cf-path=
#+BEGIN_SRC emacs-lisp
(defvar cf-dotemacs-home (file-name-directory load-file-name))

(defun cf-path (path)
  (expand-file-name path cf-dotemacs-home))
#+END_SRC
* Tangling
After cloning from [[https://github.com/xiongtx/.emacs.d][GitHub]], there is no =init.el= file, only an
=init.org= file (this file). To produce an =init.el= file, either:
** Run =org-bable-tangle=
Open =init.org= and use =C-c C-v t= to call ~org-babel-tangle~, which
extracts code blocks from the current file into =init.el=, then
restart Emacs
** Tangle Command Line
#+BEGIN_SRC sh :tangle no
emacs --batch \
      --load "/Applications/Emacs.app/Contents/Resources/lisp/org/ob-tangle.elc" \
      --eval "(org-babel-tangle-file \"~/dev/dotemacs/init.org\")"
#+END_SRC
** Automatic Tangling
To avoid having to tangle manually each time a change is made, we can add a
function to ~after-save-hook~ to tangle the =init.org= after saving.
#+BEGIN_SRC emacs-lisp
(defun cf-tangle-init-file ()
  "Tangle the current buffer if it is the init.org file."
  (when (equal (buffer-file-name) (cf-path "init.org"))
    (org-babel-tangle)))

(add-hook 'after-save-hook 'cf-tangle-init-file)
#+END_SRC
* Package Management
** Require Package
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
** Package Archives
*** Local Archive
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
           `("cf-melpa" . ,(cf-path "../cf-melpa/packages")))
#+END_SRC
*** Melpa
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/") t)
#+END_SRC
*** Org
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
           '("org" . "http://orgmode.org/elpa/") t)
#+END_SRC
*** Misc
#+BEGIN_SRC emacs-lisp
;; (add-to-list 'package-archives
;;              '("marmalade" . "https://marmalade-repo.org/packages/"))
#+END_SRC
** Initialize Package
If the variable =package-enable-at-startup= is non-nil, package
initialization occurs after the init file is loaded, but before
=after-init-hook=. We want to load packages /before/ the init file is
loaded, because we'll be referencing packages in the init file.
Therefore, we need to initialize our packages manually.
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'package-enable-at-startup nil)
(package-initialize)
#+END_SRC
** install missing packages
* General
** About Me
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'user-full-name "chunfengd")
;; (customize-set-variable 'user-mail-address "")
#+END_SRC
** Frame
*** Frame Alist
#+BEGIN_SRC emacs-lisp
(defvar cf-default-frame-alist
  '(
    ;; (width . 150)
    (width . 80)
    (height . 42)
    ))
(cond
 ((string-equal system-type "windows-nt")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    ;; (add-to-list 'initial-frame-alist '(top . 100))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "grey80")
                    (mouse-color . "dark orange"))))))
 ((string-equal system-type "darwin")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    (add-to-list 'initial-frame-alist '(top . 100))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((width . 80)
                    (height . 42)
                    (background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "purple")
                    (mouse-color . "dark orange"))))))
 ((string-equal system-type "gnu/linux")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "grey80")
                    (mouse-color . "dark orange")))))))
#+END_SRC
*** Highlight Current Line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
(if (display-graphic-p)
    (set-face-background hl-line-face "grey20"))
#+END_SRC
*** Toggle Frame Maximum
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  ;; windows
  (progn
    (defvar max-flag nil)
    (defun cf-win-toggle-frame-maximum ()
      "Toggle frame between maximum and norm."
      (interactive)
      (if (null max-flag)
          (progn
            (w32-send-sys-command 61488)
            (setq max-flag t))
        (w32-send-sys-command 61728)
        (setq max-flag nil)))
    (global-set-key [f6] 'cf-win-toggle-frame-maximum)))
 ((string-equal system-type "darwin")
  ;; mac os x
  (progn
    (defun toggle-fullscreen ()
      "Toggle full screen. From: http://emacswiki.org/emacs/FullScreen."
      (interactive)
      (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
    ;; (global-set-key [f6] 'toggle-fullscreen)
    (defun cf-reset-frame-rect ()
      "Reset the current frame to its original size"
      (interactive)
      (let ((cur-frame (selected-frame)))
        (set-frame-size cur-frame 80 42)
        (set-frame-position cur-frame 650 100)))
    (global-set-key (kbd "<f6>") 'toggle-frame-maximized)
    (global-set-key (kbd "M-<f6>") 'cf-reset-frame-rect)))
 ((string-equal system-type "gnu/linux")
  (message "linux")
  (progn
    (defun fullscreen (&optional f)
      (interactive)
      (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                             '(2 "_NET_WM_STATE_MAXIMIZED_VERT" 0))
      (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                             '(2 "_NET_WM_STATE_MAXIMIZED_HORZ" 0)))
    (defun toggle-frame-maxium ()
      (interactive)
      (when (eq window-system 'x)
        (set-frame-parameter nil 'fullscreen
         (when (not (frame-parameter nil 'fullscreen)) 'fullboth))))
    (global-set-key [f6] 'toggle-frame-maximum))))
#+END_SRC
*** Speed Bar
#+BEGIN_SRC emacs-lisp
(add-hook
 'speedbar-load-hook
 '(lambda ()
    (add-to-list 'speedbar-frame-parameters '(width . 35))
    (setq speedbar-show-unknown-files t)))
#+END_SRC
*** Menu Bar
#+BEGIN_SRC emacs-lisp
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
  (when (fboundp mode) (funcall mode -1)))
;; (menu-bar-no-scroll-bar)
;; (menu-bar-mode 0)
#+END_SRC
*** Frame Title
#+BEGIN_SRC emacs-lisp
(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b"))))
#+END_SRC
*** Fill Column
#+BEGIN_SRC emacs-lisp
(setq default-fill-column 70)
#+END_SRC
*** Column Number & =linum=
#+BEGIN_SRC emacs-lisp
(setq-default column-number-mode t)
;; linum
(global-linum-mode t)
(if (not (display-graphic-p))
    (setq linum-format "%d ")) ; for margin in terminal
;; disable linum if creating a buffer from terminal
(add-hook
 'after-change-major-mode-hook
 '(lambda ()
    (if (not (display-graphic-p))
        (linum-mode -1))))
#+END_SRC
*** Scroll
#+BEGIN_SRC emacs-lisp
(setq-default scroll-margin 3
              scroll-conservatively 10000)
#+END_SRC
** Font
*** Font Lock
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
*** Default Font
#+BEGIN_SRC emacs-lisp
(cond
 ;; windows
 ((string-equal system-type "windows-nt")
  (progn
    (set-default-font "Consolas:pixelsize=14:antialias=subpixel")
    (set-fontset-font "fontset-default"
		      'han '("Microsoft Yahei" . "unicode-bmp"))
    (add-to-list 'default-frame-alist
		 '(font . "Consolas:pixelsize=14:antialias=subpixel"))))
 ((string-equal system-type "darwin")
  (progn
    (setq default-directory "~/")
    (if (display-graphic-p)
        (set-fontset-font
         t 'han (font-spec :name "Songti SC")))))
 ;; linux
 ((string-equal system-type "gnu/linux")))
#+END_SRC
*** Font Util
#+BEGIN_SRC emacs-lisp
(defun cf-font-exist (font)
  (if (null (x-list-fonts font))
      nil t))
(defun cf-make-font-string (font-name font-size)
  (if (and (stringp font-size)
	   (equal ":" (string (elt font-size 0)))
	   )
      (format "%s%s" font-name font-size)
    (format "%s %s" font-name font-size)))
#+END_SRC
** Keys
*** Set Key Bindings Function
#+BEGIN_SRC emacs-lisp
(defun cf-set-key-bindings (action bind-list &optional map)
  "Set key bindings. 'bind-list' is 2-D list."
  (dolist (pair bind-list)
    (if (null map)
	(funcall action (eval `(kbd ,(nth 0 pair))) (nth 1 pair))
      (funcall action map (eval `(kbd ,(nth 0 pair))) (nth 1 pair)))))
#+END_SRC
*** General Keys
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(
   ("<f5>" compile)
   ("<f7>" speedbar-get-focus)
   ("C-x C-o" other-window)
   ;; ("<C-tab>" other-window)
   ("C-x C-5 C-o" other-frame)
   ("<M-tab>" other-frame)
   ("C-<" cf-pre-window)
   ("C->" other-window)
   ("C-M-<" cf-pre-frame)
   ("C-M->" other-frame)
   ("M-q" fill-region)
   ("M-s" ispell-region)
   ("C-z" undo)
   ("M-/" undo)
   ("C-?" help-command)
   ("C-t" set-mark-command)
   ("M-t" set-mark-command)
   ("C-x C-t" transpose-words)
   ;; ("C-M-t" transpose-words)
   ;; ("C-q" back-to-indentation)
   ("M-n" hippie-expand)
   ("M-m" nil)
   ("C-x f" find-file)
   ("C-x g" goto-line)
   ("M-z" server-edit)
   ("C-x C-b" switch-to-buffer)
   ("C-x b" list-buffers)
   ("C-M-a" backward-paragraph)
   ("C-M-e" forward-paragraph)
   ("C-M-w" scroll-other-window-down)
   ("C-c RET" imenu)
   ("M-o" kill-ring-save)
   ("C-c C-c" comment-or-uncomment-region)
   ("C-x C-z" nil)
   ("M-v" yank)
   ("C-w" scroll-down)
   ("M-w" mark-word)
   ;;("M-w" capitalize-word)
   ("C-y" yank)))
#+END_SRC
*** Cursor Movement
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(
   ("C-h" backward-char)
   ("C-j" next-line)
   ("C-k" previous-line)
   ("C-l" forward-char)

   ("C-b" backward-delete-char)
   ("C-n" newline-and-indent)
   ("C-p" recenter-top-bottom)
   ("C-f" kill-line)

   ("M-h" backward-word)
   ("M-j" nil)
   ("M-k" nil)
   ("M-l" forward-word)

   ("M-b" mark-paragraph)
   ;;("M-n" indent-new-comment-line)
   ("M-n" auto-complete)
   ("M-p" downcase-word)
   ;; ("M-f" kill-sentence)

   ("C-M-h" backward-sexp)
   ("C-M-j" forward-list)
   ("C-M-k" backward-list)
   ("C-M-l" forward-sexp)

   ("C-M-b" mark-defun)
   ("C-M-n" indent-new-comment-line)
   ("C-M-p" reposition-window)
   ;; ("C-M-f" kill-sexp)
   ))

(cf-set-key-bindings
 'define-key
 '(
   ("M-h" backward-word)
   ("M-l" forward-word)
   ("M-j" next-history-element)
   ("M-k" previous-history-element)
   )
 minibuffer-local-map)
#+END_SRC
** Customized Util Functions & Bindings
*** Find Map of Key Binding
Find a key binding is in which map. From [[http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs][stackoverflow]]
#+BEGIN_SRC emacs-lisp
(defun cf-overlay-key-binding (key)
  "Keymaps can also be attached to overlays, like yasnippet.
   From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (mapcar (lambda (keymap) (lookup-key keymap key))
          (cl-remove-if-not
           #'keymapp
           (mapcar (lambda (overlay)
                     (overlay-get overlay 'keymap))
                   (overlays-at (point))))))

(defun cf-find-kbd (key)
  "From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (interactive "kInput key: ")
  (message "%s"
   (list
    (cf-overlay-key-binding key)
    (minor-mode-key-binding key)
    (local-key-binding key)
    (global-key-binding key))))
#+END_SRC
*** Dos to Unix
From [[http://www.emacswiki.org/emacs/DosToUnix][emacswiki]].
#+BEGIN_SRC emacs-lisp
(defun cf-dos2unix ()
  "From: http://www.emacswiki.org/emacs/DosToUnix
Not exactly but it's easier to remember"
  (interactive)
  (set-buffer-file-coding-system 'unix 't))
#+END_SRC
*** Path Related
#+BEGIN_SRC emacs-lisp
(defun cf-get-path ()
  ""
  (interactive)
  (let ((path
         (or buffer-file-name default-directory)))
    (message path)
    path))

(defun cf-copy-path ()
  ""
  (interactive)
  (let ((path (cf-get-path)))
    (if path
        (kill-new path))))
#+END_SRC
*** Frame Related
#+BEGIN_SRC emacs-lisp
(defun cf-pre-window ()
  ""
  (interactive)
  (other-window -1))

(defun cf-pre-frame ()
  ""
  (interactive)
  (other-frame -1))
#+END_SRC
*** Forward Word
#+BEGIN_SRC emacs-lisp
(defun cf-forward-word (&optional arg)
  "Move point backward ARG words.  
Normally returns t.  If an edge of the buffer or a field boundary is
reached, point is left there and the function returns nil.
Do not bind this function to \"M-l\" or \"M-h\"!"
  (if (or (null arg) (= arg 1))
    (let
        ((start (point))
         rtnflag
         (forward (key-binding (kbd "M-l")))
         (backward (key-binding (kbd "M-h"))))
      (setq rtnflag
	    (funcall forward '1))
      (funcall backward '1)
      (if (>= start (point))
	  (funcall forward '1)
	rtnflag))
    (let ((forward (key-binding (kbd "M-l"))))
      (funcall forward arg))))
#+END_SRC
*** Kill Word
#+BEGIN_SRC emacs-lisp
(defun cf-kill-word (arg)
  "Kill characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (kill-region (point) (progn (cf-forward-word arg) (point))))
(global-set-key (kbd "M-d") 'cf-kill-word)
#+END_SRC
*** kill
#+BEGIN_SRC emacs-lisp
(defun cf-kill (beg end)
  "If the mark is active, kill region will be used; otherwise, delete
char will be used."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-region beg end)
    (delete-char 1)))
(global-set-key (kbd "C-d") 'cf-kill)
#+END_SRC
*** Open or Copy
#+BEGIN_SRC emacs-lisp
(defun cf-open-copy (beg end)
  "If the mark is active, copy region will be used; otherwise,
open a new line."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-ring-save beg end)
    (open-line 1)))
(global-set-key (kbd "C-o") 'cf-open-copy)
#+END_SRC
*** Move to the Beginning of Current Line
#+BEGIN_SRC emacs-lisp
(defun cf-move-beginning-of-line ()
  (interactive)
  (setq pos-temp (point))
  (back-to-indentation)
  (if (= (point) pos-temp)
      (move-beginning-of-line 1)))
(global-set-key (kbd "C-a") 'cf-move-beginning-of-line)
#+END_SRC
*** Magic Kill Ring Save
#+BEGIN_SRC emacs-lisp
(defun cf-magic-kill-ring-save(beg end)
  "If the mark is active, save the region to the kill-ring; otherwise,
capitalize the word."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-ring-save beg end)
    (capitalize-word 1)))
(global-set-key (kbd "M-c") 'cf-magic-kill-ring-save)
#+END_SRC
*** Indent Regidly Inverse
#+BEGIN_SRC emacs-lisp
(defun cf-indent-regidly-inverse (start end)
  (interactive "r")
  (indent-rigidly start end -1))
#+END_SRC
*** Eval and Replace
From: http://emacsredux.com/blog/2013/06/21/eval-and-replace/
#+BEGIN_SRC emacs-lisp
(defun cf-eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
(global-set-key (kbd "C-x C-e") 'cf-eval-and-replace)
#+END_SRC
*** Revert All Buffers
From: http://blog.plover.com/prog/revert-all.html
#+BEGIN_SRC emacs-lisp
(defun cf-revert-all-buffers ()
  "Refreshes all open buffers from their respective files"
  (interactive)
  (let* ((list (buffer-list))
         (buffer (car list)))
    (while buffer
      (when (and (buffer-file-name buffer)
                 (not (buffer-modified-p buffer)))
        (set-buffer buffer)
        (revert-buffer t t t))
      (setq list (cdr list))
      (setq buffer (car list))))
  (message "Refreshed open files"))
#+END_SRC
*** Open Webstorm
#+BEGIN_SRC emacs-lisp
(defun cf-run-cmd-on-current-file (command)
  "run a command on the current file"
  (shell-command
   (format "open -a %s %s" command
           (shell-quote-argument (buffer-file-name)))))

(defun cf-open-webstorm ()
  (interactive)
  (cf-run-cmd-on-current-file "webstorm"))

;; (cf-set-key-bindings 'global-set-key '(("C-<f9>" cf-open-webstorm)))
#+END_SRC
** Misc
*** Mac Key
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  ;; windows
  (progn
    ))
 ((string-equal system-type "darwin")
  ;; mac os x
  (progn
    (setq mac-option-key-is-meta nil)
    (setq mac-command-key-is-meta t)
    ;;(setq mac-command-modifier 'meta)
    ;;(setq mac-option-modifier nil)
    ;; (setenv "NODE_NO_READLINE" "1")
    ;; (exec-path-from-shell-initialize)
    ))
 ((string-equal system-type "gnu/linux")
  (message "linux")
  (progn
    (defconst cf-system-include-dirs nil))))
#+END_SRC
*** Parentheses
#+BEGIN_SRC emacs-lisp
;; (setq show-paren-mode t) ; does not work
(setq show-paren-mode nil)
(show-paren-mode)
(setq show-paren-style 'mixed)
#+END_SRC
*** Indent Tab
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq default-tab-width 8)
#+END_SRC
*** Backup Files
#+BEGIN_SRC emacs-lisp
(setq-default make-backup-files nil)
#+END_SRC
*** Visible Bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
*** Narrow
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC
*** Delete Selection Mode
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
*** Inhibit Startup Message
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Sentence End Double Space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Uniquify Buffer Name
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
*** Diff
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq diff-switches "-u")
#+END_SRC
*** Save Place
#+BEGIN_SRC emacs-lisp
(setq save-place-file (concat user-emacs-directory "places"))
#+END_SRC
*** Daemon Server
#+BEGIN_SRC emacs-lisp :tangle no
(setq server-name "server")
(server-start)
#+END_SRC
*** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(if (package-installed-p 'exec-path-from-shell)
    (progn
     (require 'exec-path-from-shell)
     (cond
      ((string-equal system-type "windows-nt")
       ;; windows
       (progn
         (exec-path-from-shell-initialize)))
      ((string-equal system-type "darwin")
       ;; mac os x
       (progn
         (exec-path-from-shell-initialize)))))
  (message "exec-path-from-shell not installed"))
#+END_SRC
