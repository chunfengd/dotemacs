#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :comments org

#+TITLE: Emacs Configuration File
#+AUTHOR: Chunfeng Dai

# Adapted from Lars Tveito's and Tianxiang Xiong's excellent
# configuration files.
# See:
#   - https://github.com/larstvei/dot-emacs/blob/master/init.org
#   - https://github.com/xiongtx/.emacs.d/blob/master/init.org

* Table of Contents                                                     :TOC:
 - [[#introduction][Introduction]]
 - [[#dotemacs-path][Dotemacs Path]]
   - [[#define-cf-path][Define =cf-path=]]
   - [[#extra-load-path][Extra load path]]
 - [[#tangling-and-how-to-install][Tangling and How to Install]]
   - [[#run-org-bable-tangle][Run =org-bable-tangle=]]
   - [[#tangle-command-line][Tangle Command Line]]
   - [[#automatic-tangling][Automatic Tangling]]
   - [[#add-the-following-line-into-emacs][Add the following line into =~/.emacs=]]
 - [[#package-management][Package Management]]
   - [[#require-package][Require Package]]
   - [[#package-archives][Package Archives]]
   - [[#initialize-package][Initialize Package]]
   - [[#install-missing-packages][install missing packages]]
 - [[#general][General]]
   - [[#about-me][About Me]]
   - [[#frame][Frame]]
   - [[#font][Font]]
   - [[#keys][Keys]]
   - [[#customized-util-functions--bindings][Customized Util Functions & Bindings]]
   - [[#emacs-default-auto-save][emacs default auto save]]
   - [[#auto-save][Auto Save]]
   - [[#misc][Misc]]
 - [[#evil-mode][evil-mode]]
   - [[#insert-char][insert-char]]
   - [[#init][init]]
 - [[#org-mode][org-mode]]
   - [[#init-1][init]]
   - [[#add-agenda-files-into-emacs][add agenda files into =~/.emacs=]]
   - [[#cf-org-beginning-of-line][cf-org-beginning-of-line]]
   - [[#org-mode-hook][org-mode-hook]]
   - [[#agenda-hook][agenda-hook]]
   - [[#custom-agenda-commands][custom agenda commands]]
   - [[#keyword-faces][Keyword Faces]]
   - [[#deadline-warning-days][Deadline Warning Days]]
   - [[#use-toc-org-to-automatically-generate-a-table-of-contents-for-org-files][Use toc-org to automatically generate a table of contents for Org files.]]
 - [[#text-mode][text-mode]]
   - [[#auto-fill][Auto Fill]]
   - [[#pro-file][Pro File]]
 - [[#helm][helm]]
   - [[#setup-helm][Setup helm]]
   - [[#setup-projectile][Setup projectile]]
   - [[#setup-helm-ag][Setup helm-ag]]
 - [[#lisp-interaction-mode][lisp-interaction-mode]]
 - [[#cc-mode][cc-mode]]
 - [[#cedet][cedet]]
 - [[#cmake][cmake]]
 - [[#company][company]]
   - [[#init-2][init]]
   - [[#company-quickhelp][company-quickhelp]]
   - [[#misc-1][misc]]
   - [[#company-c-headers][company-c-headers]]
 - [[#dired][dired]]
   - [[#display-in-other-window-or-copy-selected][display in other window or copy selected]]
   - [[#key-binding][key binding]]
   - [[#listing-parameters][Listing Parameters]]
 - [[#expand-region][expand-region]]
 - [[#flycheck][flycheck]]
   - [[#functions][functions]]
 - [[#folding][Folding]]
   - [[#main-code][Main Code]]
   - [[#key-binding-1][Key Binding]]
   - [[#example][Example]]
   - [[#test][Test]]
   - [[#todo][Todo]]
 - [[#graphviz-dot-mode][Graphviz Dot Mode]]
 - [[#highlight-indentation][highlight-indentation]]
 - [[#html][html]]
   - [[#html-mode][html-mode]]
   - [[#nxml-mode][nxml-mode]]
   - [[#web-mode][web-mode]]
 - [[#imenu][imenu]]
 - [[#java][java]]
 - [[#js][js]]
   - [[#node-modules-path-setup][node-modules-path-setup]]
   - [[#js-mode][js-mode]]
   - [[#js2-mode][js2-mode]]
   - [[#js3-mode][js3-mode]]
   - [[#json-mode][json-mode]]
 - [[#jump-avy][jump (avy)]]
 - [[#latex][latex]]
   - [[#tex-mode][tex-mode]]
   - [[#bibtex-mode][bibtex-mode]]
 - [[#lisp][lisp]]
   - [[#paredit][paredit]]
   - [[#clojure][clojure]]
 - [[#multiple-cursors][multiple-cursors]]
 - [[#markdown][markdown]]
 - [[#outline][outline]]
 - [[#python][python]]
 - [[#ruby][ruby]]
 - [[#scss][scss]]
 - [[#shell][shell]]
   - [[#sh-mode][sh mode]]
   - [[#shell-mode][shell mode]]
   - [[#term-mode][term mode]]
   - [[#tm-function][tm function]]
   - [[#sh-function][sh function]]
 - [[#speedbar][speedbar]]
 - [[#spell][spell]]
 - [[#tramp][tramp]]
 - [[#view][view]]
 - [[#asm][asm]]
 - [[#prettier][prettier]]
 - [[#find-library-file][Find Library File]]
 - [[#list][List]]
   - [[#read-a-list-of-people-with-nice-emacs-config-files][read a list of people with nice emacs config files]]
   - [[#toc-org][toc-org]]
   - [[#magit][magit]]
 - [[#license][License]]

* Introduction
:PROPERTIES:
:header-args: :tangle no
:END:
This is an Emacs configuration file written in Org-mode. It is adapted
from Lars Tveito's excellent [[https://github.com/larstvei/dot-emacs/blob/master/init.org][config file]] and Tianxiang Xiong's [[https://github.com/xiongtx/.emacs.d/blob/master/init.org][config]]
on GitHub.
* Dotemacs Path
** Define =cf-path=
#+BEGIN_SRC emacs-lisp
(defvar cf-dotemacs-home (file-name-directory load-file-name))

(defun cf-path (path)
  (expand-file-name path cf-dotemacs-home))
#+END_SRC
** Extra load path
- updated from
  https://github.com/redguardtoo/emacs.d/blob/master/init.el
#+begin_src emacs-lisp
(defun my-add-site-dir (site-dir)
  "Add a directory into `load-path'."
  (setq load-path
        (append
         (delq nil
               (mapcar (lambda (dir)
                         (unless (string-match-p "^\\." dir)
                           (expand-file-name dir site-dir)))
                       (directory-files site-dir)))
         load-path)))
(my-add-site-dir (cf-path "site"))
#+end_src
* Tangling and How to Install
After cloning from [[https://github.com/xiongtx/.emacs.d][GitHub]], there is no =init.el= file, only an
=init.org= file (this file). To produce an =init.el= file, either:
** Run =org-bable-tangle=
Open =init.org= and use =C-c C-v t= to call ~org-babel-tangle~, which
extracts code blocks from the current file into =init.el=, then
restart Emacs
** Tangle Command Line
#+BEGIN_SRC sh :tangle no
$ ./tangle.sh
#+END_SRC
or
#+BEGIN_SRC sh :tangle no
$ emacs --batch \
        --eval "(require 'ob-tangle)" \
        --eval "(org-babel-tangle-file \"./init.org\")"
#+END_SRC
** Automatic Tangling
To avoid having to tangle manually each time a change is made, we can add a
function to ~after-save-hook~ to tangle the =init.org= after saving.
#+BEGIN_SRC emacs-lisp
(defun cf-tangle-init-file ()
  "Tangle the current buffer if it is the init.org file."
  (when (equal (buffer-file-name) (cf-path "init.org"))
    (org-babel-tangle)))

(add-hook 'after-save-hook 'cf-tangle-init-file)
#+END_SRC
** Add the following line into =~/.emacs=
#+BEGIN_SRC emacs-lisp :tangle no
(load "/path/to/init.el")
#+END_SRC
* Package Management
** Require Package
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
** Package Archives
*** Local Archive
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
           `("cf-melpa" . ,(cf-path "../cf-melpa/packages")))
#+END_SRC
*** Melpa
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/")
             t)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/")
             t)
#+END_SRC
*** Org
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
           '("org" . "http://orgmode.org/elpa/") t)
#+END_SRC
*** Misc
#+BEGIN_SRC emacs-lisp
;; (add-to-list 'package-archives
;;              '("marmalade" . "https://marmalade-repo.org/packages/"))
#+END_SRC
** Initialize Package
If the variable =package-enable-at-startup= is non-nil, package
initialization occurs after the init file is loaded, but before
=after-init-hook=. We want to load packages /before/ the init file is
loaded, because we'll be referencing packages in the init file.
Therefore, we need to initialize our packages manually.
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'package-enable-at-startup nil)
(package-initialize)
#+END_SRC
** install missing packages
* General
** About Me
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'user-full-name "Chunfeng Dai")
;; (customize-set-variable 'user-mail-address "")
#+END_SRC
** Frame
*** Frame Alist
#+BEGIN_SRC emacs-lisp
(defvar cf-default-frame-alist
  '(
    ;; (width . 150)
    (width . 80)
    (height . 42)
    ))
(cond
 ((string-equal system-type "windows-nt")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    ;; (add-to-list 'initial-frame-alist '(top . 100))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "grey80")
                    (mouse-color . "dark orange"))))))
 ((string-equal system-type "darwin")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    (add-to-list 'initial-frame-alist '(top . 100))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((width . 80)
                    (height . 42)
                    (background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "purple")
                    (mouse-color . "dark orange"))))))
 ((string-equal system-type "gnu/linux")
  (progn
    (add-to-list 'initial-frame-alist '(left . 650))
    (setq default-frame-alist
          (append cf-default-frame-alist
                  '((background-color . "black")
                    (foreground-color . "grey75")
                    (border-color . "white")
                    (cursor-color . "grey80")
                    (mouse-color . "dark orange")))))))
#+END_SRC
*** Highlight Current Line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
(if (display-graphic-p)
    (set-face-background hl-line-face "grey20"))
#+END_SRC
*** Toggle Frame Maximum
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  ;; windows
  (progn
    (defvar max-flag nil)
    (defun cf-win-toggle-frame-maximum ()
      "Toggle frame between maximum and norm."
      (interactive)
      (if (null max-flag)
          (progn
            (w32-send-sys-command 61488)
            (setq max-flag t))
        (w32-send-sys-command 61728)
        (setq max-flag nil)))
    (global-set-key [f6] 'cf-win-toggle-frame-maximum)))
 ((string-equal system-type "darwin")
  ;; mac os x
  (progn
    (defun toggle-fullscreen ()
      "Toggle full screen. From: http://emacswiki.org/emacs/FullScreen."
      (interactive)
      (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
    ;; (global-set-key [f6] 'toggle-fullscreen)
    (defun cf-reset-frame-rect ()
      "Reset the current frame to its original size"
      (interactive)
      (let ((cur-frame (selected-frame)))
        (set-frame-size cur-frame 80 42)
        (set-frame-position cur-frame 650 100)))
    (global-set-key (kbd "<f6>") 'toggle-frame-maximized)
    (global-set-key (kbd "M-<f6>") 'cf-reset-frame-rect)))
 ((string-equal system-type "gnu/linux")
  (message "linux")
  (progn
    (defun fullscreen (&optional f)
      (interactive)
      (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                             '(2 "_NET_WM_STATE_MAXIMIZED_VERT" 0))
      (x-send-client-message nil 0 nil "_NET_WM_STATE" 32
                             '(2 "_NET_WM_STATE_MAXIMIZED_HORZ" 0)))
    (defun toggle-frame-maxium ()
      (interactive)
      (when (eq window-system 'x)
        (set-frame-parameter nil 'fullscreen
         (when (not (frame-parameter nil 'fullscreen)) 'fullboth))))
    (global-set-key [f6] 'toggle-frame-maximum))))
#+END_SRC
*** Speed Bar
#+BEGIN_SRC emacs-lisp
(add-hook
 'speedbar-load-hook
 '(lambda ()
    (add-to-list 'speedbar-frame-parameters '(width . 35))
    (setq speedbar-show-unknown-files t)))
#+END_SRC
*** Menu Bar
#+BEGIN_SRC emacs-lisp
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
  (when (fboundp mode) (funcall mode -1)))
;; (menu-bar-no-scroll-bar)
;; (menu-bar-mode 0)
#+END_SRC
*** Frame Title
#+BEGIN_SRC emacs-lisp
(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b"))))
#+END_SRC
*** Fill Column
#+BEGIN_SRC emacs-lisp
(setq default-fill-column 70)
#+END_SRC
*** Column Number & =linum=
#+BEGIN_SRC emacs-lisp
(setq-default column-number-mode t)
;; linum
(global-linum-mode t)
(if (not (display-graphic-p))
    (setq linum-format "%d ")) ; for margin in terminal
;; disable linum if creating a buffer from terminal
(add-hook
 'after-change-major-mode-hook
 '(lambda ()
    (if (not (display-graphic-p))
        (linum-mode -1))))
#+END_SRC
*** Scroll
#+BEGIN_SRC emacs-lisp
(setq-default scroll-margin 3
              scroll-conservatively 10000)
#+END_SRC
** Font
*** Font Lock
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
*** Default Font
#+BEGIN_SRC emacs-lisp
(cond
 ;; windows
 ((string-equal system-type "windows-nt")
  (progn
    (set-default-font "Consolas:pixelsize=14:antialias=subpixel")
    (set-fontset-font "fontset-default"
		      'han '("Microsoft Yahei" . "unicode-bmp"))
    (add-to-list 'default-frame-alist
		 '(font . "Consolas:pixelsize=14:antialias=subpixel"))))
 ((string-equal system-type "darwin")
  (progn
    (setq default-directory "~/")
    (if (display-graphic-p)
        (set-fontset-font
         t 'han (font-spec :name "Songti SC")))))
 ;; linux
 ((string-equal system-type "gnu/linux")))
#+END_SRC
*** Font Util
#+BEGIN_SRC emacs-lisp
(defun cf-font-exist (font)
  (if (null (x-list-fonts font))
      nil t))
(defun cf-make-font-string (font-name font-size)
  (if (and (stringp font-size)
	   (equal ":" (string (elt font-size 0)))
	   )
      (format "%s%s" font-name font-size)
    (format "%s %s" font-name font-size)))
#+END_SRC
** Keys
*** switch C-c & C-g
#+BEGIN_SRC emacs-lisp
(keyboard-translate ?\C-c ?\C-g)
(keyboard-translate ?\C-g ?\C-c)
#+END_SRC
*** Set Key Bindings Function
#+BEGIN_SRC emacs-lisp
(defun cf-set-key-bindings (action bind-list &optional map)
  "Set key bindings. 'bind-list' is 2-D list."
  (dolist (pair bind-list)
    (if (null map)
	(funcall action (eval `(kbd ,(nth 0 pair))) (nth 1 pair))
      (funcall action map (eval `(kbd ,(nth 0 pair))) (nth 1 pair)))))
#+END_SRC
*** General Keys
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(
   ("<f5>" compile)
   ("<f7>" speedbar-get-focus)
   ("C-x C-o" other-window)
   ;; ("<C-tab>" other-window)
   ("C-x C-5 C-o" other-frame)
   ("<M-tab>" other-frame)
   ("C-<" cf-pre-window)
   ("C->" other-window)
   ("C-M-<" cf-pre-frame)
   ("C-M->" other-frame)
   ("M-q" fill-region)
   ("M-s" ispell-region)
   ;; ("C-z" undo)
   ("M-/" undo)
   ("C-?" help-command)
   ("C-t" set-mark-command)
   ("M-t" set-mark-command)
   ;; ("C-x C-t" transpose-words)
   ;; ("C-M-t" transpose-words)
   ;; ("C-q" back-to-indentation)
   ("M-n" hippie-expand)
   ("M-m" nil)
   ("C-x f" find-file)
   ("C-x g" goto-line)
   ;; ("M-z" server-edit)
   ("C-x C-b" switch-to-buffer)
   ("C-x b" list-buffers)
   ;; ("C-M-a" backward-paragraph)
   ;; ("C-M-e" forward-paragraph)
   ("C-M-b" scroll-other-window-down)
   ("C-M-f" scroll-other-window)
   ("C-c RET" imenu)
   ;; ("M-o" kill-ring-save)
   ("C-c C-c" comment-or-uncomment-region)
   ("C-x C-z" nil)
   ("M-v" yank)
   ;; ("C-w" scroll-down)
   ("M-w" mark-word)
   ;;("M-w" capitalize-word)
   ("C-y" yank)))
#+END_SRC
** Customized Util Functions & Bindings
*** Find Map of Key Binding
Find a key binding is in which map. From [[http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs][stackoverflow]]
#+BEGIN_SRC emacs-lisp
(defun cf-overlay-key-binding (key)
  "Keymaps can also be attached to overlays, like yasnippet.
   From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (mapcar (lambda (keymap) (lookup-key keymap key))
          (cl-remove-if-not
           #'keymapp
           (mapcar (lambda (overlay)
                     (overlay-get overlay 'keymap))
                   (overlays-at (point))))))

(defun cf-find-kbd (key)
  "From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (interactive "kInput key: ")
  (message "%s"
   (list
    (cf-overlay-key-binding key)
    (minor-mode-key-binding key)
    (local-key-binding key)
    (global-key-binding key))))
#+END_SRC
*** Dos to Unix
From [[http://www.emacswiki.org/emacs/DosToUnix][emacswiki]].
#+BEGIN_SRC emacs-lisp
(defun cf-dos2unix ()
  "From: http://www.emacswiki.org/emacs/DosToUnix
Not exactly but it's easier to remember"
  (interactive)
  (set-buffer-file-coding-system 'unix 't))
#+END_SRC
*** Path Related
#+BEGIN_SRC emacs-lisp
(defun cf-get-path ()
  ""
  (interactive)
  (let ((path
         (or buffer-file-name default-directory)))
    (message path)
    path))

(defun cf-copy-path ()
  ""
  (interactive)
  (let ((path (cf-get-path)))
    (if path
        (kill-new path))))
#+END_SRC
*** Frame Related
#+BEGIN_SRC emacs-lisp
(defun cf-pre-window ()
  ""
  (interactive)
  (other-window -1))

(defun cf-pre-frame ()
  ""
  (interactive)
  (other-frame -1))
#+END_SRC
*** Kill Word
#+BEGIN_SRC emacs-lisp
(defun cf-kill-word (arg)
  "Kill characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (kill-region (point) (progn (cf-forward-word arg) (point))))
(global-set-key (kbd "M-d") 'cf-kill-word)
#+END_SRC
*** kill
#+BEGIN_SRC emacs-lisp
(defun cf-kill (beg end)
  "If the mark is active, kill region will be used; otherwise, delete
char will be used."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-region beg end)
    (delete-char 1)))
(global-set-key (kbd "C-d") 'cf-kill)
#+END_SRC
*** Move to the Beginning of Current Line
#+BEGIN_SRC emacs-lisp
(defun cf-move-beginning-of-line ()
  (interactive)
  (setq pos-temp (point))
  (back-to-indentation)
  (if (= (point) pos-temp)
      (move-beginning-of-line 1)))
(global-set-key (kbd "C-a") 'cf-move-beginning-of-line)
#+END_SRC
*** Indent Regidly Inverse
#+BEGIN_SRC emacs-lisp
(defun cf-indent-regidly-inverse (start end)
  (interactive "r")
  (indent-rigidly start end -1))
#+END_SRC
*** Eval and Replace
From: http://emacsredux.com/blog/2013/06/21/eval-and-replace/
#+BEGIN_SRC emacs-lisp
(defun cf-eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
(global-set-key (kbd "C-x C-e") 'cf-eval-and-replace)
#+END_SRC
*** Revert All Buffers
From: http://blog.plover.com/prog/revert-all.html
#+BEGIN_SRC emacs-lisp
(defun cf-revert-all-buffers ()
  "Refreshes all open buffers from their respective files"
  (interactive)
  (let* ((list (buffer-list))
         (buffer (car list)))
    (while buffer
      (when (and (buffer-file-name buffer)
                 (not (buffer-modified-p buffer)))
        (set-buffer buffer)
        (revert-buffer t t t))
      (setq list (cdr list))
      (setq buffer (car list))))
  (message "Refreshed open files"))
#+END_SRC
*** Open Webstorm
#+BEGIN_SRC emacs-lisp
(defun cf-run-cmd-on-current-file (command)
  "run a command on the current file"
  (shell-command
   (format "open -a %s %s" command
           (shell-quote-argument (buffer-file-name)))))

(defun cf-open-webstorm ()
  (interactive)
  (cf-run-cmd-on-current-file "webstorm"))

;; (cf-set-key-bindings 'global-set-key '(("C-<f9>" cf-open-webstorm)))
#+END_SRC
*** idle
- ref: https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-utils.el
#+begin_src emacs-lisp
(defvar my-disable-idle-timer nil
  "Function passed to `my-run-with-idle-timer' is run immediately.")

(defun my-run-with-idle-timer (seconds func)
  "After SECONDS, run function FUNC once."
  (cond
   (my-disable-idle-timer
    (funcall func))
   (t
    (run-with-idle-timer seconds nil func))))
#+end_src
** emacs default auto save
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/17210/how-to-place-all-auto-save-files-in-a-directory
(setq auto-save-file-name-transforms
  `((".*" "~/.emacs-saves/" t)))
#+end_src
** Auto Save
- refs
  - https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-misc.el
  - https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-autoload.el
#+begin_src emacs-lisp
(defun setup-auto-save ()
  (autoload 'auto-save-enable "auto-save" "" t)
  (with-eval-after-load 'auto-save
    (push 'my-file-too-big-p auto-save-exclude)
    (push 'my-check-major-mode-for-auto-save auto-save-exclude)
    (setq auto-save-idle 1)
    (setq auto-save-slient t))
  (my-run-with-idle-timer 1 #'auto-save-enable))
(setup-auto-save)
#+end_src
** Misc
*** Mac Key
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  ;; windows
  (progn
    ))
 ((string-equal system-type "darwin")
  ;; mac os x
  (progn
    (setq mac-option-key-is-meta nil)
    (setq mac-command-key-is-meta t)
    ;;(setq mac-command-modifier 'meta)
    ;;(setq mac-option-modifier nil)
    ;; (setenv "NODE_NO_READLINE" "1")
    ;; (exec-path-from-shell-initialize)
    ))
 ((string-equal system-type "gnu/linux")
  (message "linux")
  (progn
    (defconst cf-system-include-dirs nil))))
#+END_SRC
*** Parentheses
#+BEGIN_SRC emacs-lisp
;; (setq show-paren-mode t) ; does not work
(setq show-paren-mode nil)
(show-paren-mode)
(setq show-paren-style 'mixed)
#+END_SRC
*** Indent Tab
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq default-tab-width 8)
#+END_SRC
*** Backup Files
#+BEGIN_SRC emacs-lisp
(setq-default make-backup-files nil)
#+END_SRC
*** Visible Bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC
*** Narrow
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC
*** Delete Selection Mode
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
*** Inhibit Startup Message
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Sentence End Double Space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Uniquify Buffer Name
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
*** Diff
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq diff-switches "-u")
#+END_SRC
*** Save Place
#+BEGIN_SRC emacs-lisp
(setq save-place-file (concat user-emacs-directory "places"))
#+END_SRC
*** Daemon Server
#+BEGIN_SRC emacs-lisp
(setq server-name "emacs-server")
(server-start)
#+END_SRC
*** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(if (package-installed-p 'exec-path-from-shell)
    (progn
     (require 'exec-path-from-shell)
     (cond
      ((string-equal system-type "windows-nt")
       ;; windows
       (progn
         (exec-path-from-shell-initialize)))
      ((string-equal system-type "darwin")
       ;; mac os x
       (progn
         (exec-path-from-shell-initialize)))))
  (message "exec-path-from-shell not installed"))
#+END_SRC
*** Default major mode
#+BEGIN_SRC emacs-lisp
(setq default-major-mode 'text-mode)
#+END_SRC
*** auto reload
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
*** electric pair
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC
* evil-mode
- github: https://github.com/emacs-evil/evil
- doc: https://evil.readthedocs.io/en/latest/index.html
** insert-char
#+begin_src emacs-lisp
(defun cf-define-insert-char ()
  ;; from: https://www.reddit.com/r/emacs/comments/7ogu7a/single_character_insert_for_evil/
  ;; (evil-define-command my-evil-insert-char (count char)
  ;;   (interactive "<c><C>")
  ;;   (setq count (or count 1))
  ;;   (insert (make-string count char)))
  ;; (evil-define-command my-evil-append-char (count char)
  ;;   (interactive "<c><C>")
  ;;   (setq count (or count 1))
  ;;   (when (not (eolp))
  ;;     (forward-char))
  ;;   (insert (make-string count char)))
  ;; (define-key evil-normal-state-map (kbd "s") 'my-evil-insert-char)
  ;; (define-key evil-normal-state-map (kbd "S") 'my-evil-append-char)

  (defun cf-evil-insert-char ()
    "insert single character"
    (interactive)
    (evil-insert 1))
  (defun cf-evil-append-char ()
    "append single character"
    (interactive)
    (evil-append 1))
  (define-key evil-normal-state-map (kbd "s") 'cf-evil-insert-char)
  (define-key evil-normal-state-map (kbd "S") 'cf-evil-append-char)
  (define-key evil-normal-state-map (kbd "C-a") 'cf-evil-insert-char)
  ;; check last-command in post-command-hook
  (defun cf-switch-back-to-normal-state ()
    "switch back to normal mode if needed"
    (when (or (equal last-command 'cf-evil-insert-char)
              (equal last-command 'cf-evil-append-char))
      (evil-normal-state)))
  (add-hook 'post-command-hook 'cf-switch-back-to-normal-state)
  )
#+end_src
** init
#+BEGIN_SRC emacs-lisp
(defun cf-config-evil ()
  ;; (setq evil-want-C-u-delete t)
  ;; (setq evil-want-C-u-scroll t)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-shift-width 2))
(defun cf-setup-evil ()
  (cf-config-evil)
  (require 'evil)
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'backward-delete-char)
  (define-key evil-replace-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-replace-state-map (kbd "C-h") 'backward-delete-char)
  (cf-define-insert-char)
  )
(if (and (package-installed-p 'evil)
         (package-installed-p 'undo-tree)
         (package-installed-p 'goto-chg))
    (cf-setup-evil)
  (message "evil, undo-tree or goto-chg not installed"))
#+END_SRC
* org-mode
** init
#+BEGIN_SRC emacs-lisp
(require 'org-install)
(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
#+END_SRC
** add agenda files into =~/.emacs=
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-files
      '("~/path/to/todo/todo.org"))

(setq org-agenda-tetra
      "~/path/to/todo/tetra.org")
#+END_SRC
** cf-org-beginning-of-line
#+BEGIN_SRC emacs-lisp
(defun cf-org-beginning-of-line ()
  (interactive)
  (setq pos-temp (point))
  (back-to-indentation)
  (if (= (point) pos-temp)
      (org-beginning-of-line 1)))
#+END_SRC
** org-mode-hook
#+BEGIN_SRC emacs-lisp
(defun cf-org-mode-hook-func ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; "C-c C-b" org-backward-heading-same-level
     ;; "C-c C-f" org-forward-heading-same-level
     ;; "C-c C-n" outline-next-visible-heading
     ("C-c C-p" outline-previous-visible-heading)
     ;; "C-c C-j" org-goto

     ;; ("M-<left>" org-metaleft)
     ;; ("M-<righ>" org-metaright)
     ;; ("M-<up>" org-metaup)
     ;; ("M-<down>" org-metadown)

     ;; ("M-S-<left>" org-shiftmetaleft)
     ;; ("M-S-<right>" org-shiftmetaright)
     ;; ("M-S-<up>" org-shiftmetaup)
     ;; ("M-S-<down>" org-shiftmetadown)

     ;; "M-h" org-mark-element

     ;; ("C-c C-f" org-kill-note-or-show-branches) ;; used to be 'C-c C-k'

     ("C-<tab>" org-cycle)
     ("C-S-<tab>" org-shifttab)
     ("C-a" cf-org-beginning-of-line)
     ("C-c RET" nil)

     ;; ("C-S-i" org-table-previous-field)
     ;; ("M-S-RET" org-table-wrap-region)

     ;; ("C-c C-x C-p" org-preview-latex-fragment)

     ;; ("C-c [" nil) ;; org-agenda-file-to-front
     ;; ("C-c ]" nil) ;; org-remove-file
     ))
  ;; (cf-set-key-bindings
  ;;  'define-key
  ;;  '(
  ;;    ("C-M-h" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-day 1))))
  ;;    ("C-M-l" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-day 1))))
  ;;    ("C-M-k" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-week 1))))
  ;;    ("C-M-j" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-week 1))))
  ;;    ("C-M-S-h" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-month 1))))
  ;;    ("C-M-S-l" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-month 1))))
  ;;    )
  ;; org-read-date-minibuffer-local-map)
  (linum-mode 0)
  (org-indent-mode t)
  (flyspell-mode-off)
  (setq org-src-fontify-natively t)
  (setq org-edit-src-content-indentation 0)
  ;; (setq org-infojs-options cf-default-org-infojs-options)
  (setq org-export-html-use-infojs t) ; alternative: when-configured, nil
  (setq org-latex-preview-ltxpng-directory "/tmp/ltxpng/")
  )
(add-hook 'org-mode-hook 'cf-org-mode-hook-func)
#+END_SRC
** agenda-hook
#+BEGIN_SRC emacs-lisp
(defun cf-org-agenda-mode-hook-func ()
  (cf-set-key-bindings
   'define-key
   '(
     ("j" org-agenda-next-line)
     ("k" org-agenda-previous-line)
     ("J" org-agenda-next-item)
     ("K" org-agenda-previous-item)
     ("g" org-agenda-goto-date)
     ("G" org-agenda-clock-goto)
     )
   org-agenda-mode-map))
(add-hook 'org-agenda-mode-hook 'cf-org-agenda-mode-hook-func)
#+END_SRC
** custom agenda commands
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("d" "Daily Agenda and All TODOs"
         ((agenda "" ((org-agenda-ndays 1)))
          (alltodo ""
                   ((org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "HOLD" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))
          (alltodo ""
                   ((org-agenda-skip-function
                     '(or (org-agenda-skip-entry-if 'scheduled 'deadline)
                          (org-agenda-skip-entry-if 'todo '("HOLD"))))
                    (org-agenda-overriding-header "Todo Tasks without time:"))))
         ;; ((org-agenda-compact-blocks t))
         )
        ("h" "All Holds"
         ((alltodo ""
                   ((org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "PROG" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))))
        ("t" "Tetrascience"
         ((agenda ""
                  ((org-agenda-files `(,org-agenda-tetra))
                   (org-agenda-ndays 1)))
          (alltodo ""
                   ((org-agenda-files `(,org-agenda-tetra))
                    (org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "HOLD" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))
          (alltodo ""
                   ((org-agenda-files `(,org-agenda-tetra))
                    (org-agenda-skip-function
                     '(or (org-agenda-skip-entry-if 'scheduled 'deadline)
                          (org-agenda-skip-entry-if 'todo '("HOLD"))))
                    (org-agenda-overriding-header "Todo Tasks without time:")))))))
#+END_SRC
** Todo Keyword Faces
#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      '(("TODO" . org-warning)
        ("IN-PROGRESS" . "yellow")
        ("PROG" . "yellow")
        ("PROGRESS" . "yellow")
        ("DONE" . "green")
        ("HOLD" . "red")
        ("CANCELLED" . "purple1")))
#+END_SRC
** Deadline Warning Days
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 10)
#+END_SRC
** Use toc-org to automatically generate a table of contents for Org files.
#+BEGIN_SRC emacs-lisp
(defun cf-setup-toc-org ()
  (add-hook 'org-mode-hook #'toc-org-enable))

(if (package-installed-p 'toc-org)
    (cf-setup-toc-org)
  (message "toc-org not installed"))
#+END_SRC
* text-mode
** Auto Fill
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Pro File
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.pro$" . text-mode))
#+END_SRC
* helm
- http://tuhdo.github.io/helm-intro.html
- http://tuhdo.github.io/helm-projectile.html
- https://github.com/bbatsov/projectile
** Setup helm
#+BEGIN_SRC emacs-lisp
(defun cf-setup-helm ()
  (require 'helm)
  (require 'helm-config)

  ;; keys
  (cf-set-key-bindings
   'global-set-key
   '(("M-x" helm-M-x)
     ("M-y" helm-show-kill-ring)
     ("C-x C-b" helm-mini)
     ("C-x C-f" helm-find-files)
     ;; ("C-x C-h C-p" helm-projectile)
     ("C-x C-p" helm-projectile)
     ("C-x C-d" helm-projectile-find-dir)
     ("C-x C-m" helm-semantic-or-imenu)
     ("C-x C-r" helm-resume)
     ("C-x C-h C-o" helm-occur)
     ("C-x C-h C-p" helm-projectile-switch-project)
     ("C-x C-h C-r" helm-resume)
     ("C-x C-h C-m" helm-all-mark-rings)
     ("C-x C-h C-g" helm-projectile-ag)
     ("C-x C-h C-k" helm-projectile-grep)
     ("C-x C-h C-a" helm-do-ag)
     ))

  ;; general
  ;; open helm buffer inside current window
  (setq helm-split-window-in-side-p t)
  ;; (setq helm-move-to-line-cycle-in-source t)
  ;; M-x
  (setq helm-M-x-fuzzy-match t)
  ;; Mini
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t)
  ;; imenu
  (setq helm-semantic-fuzzy-match t
        helm-imenu-fuzzy-match    t)
  (setq helm-ff-file-name-history-use-recentf t)
  ;; (helm-autoresize-mode t)
  ;; ;; 40% of current frame height
  ;; (setq helm-autoresize-max-height 40)
  ;; (setq helm-ff-search-library-in-sexp t)
  ;; (setq helm-scroll-amount 8)

  (helm-mode 1)

  (defun cf-bind-helm ()
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     minibuffer-local-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-generic-files-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-find-files-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-read-file-map)
    (cf-set-key-bindings
     'define-key
     '(
       ;; C-j helm-execute-persistent-action
       ;; C-] helm-toggle-buffers-details
       ("C-M-b" helm-scroll-other-window-down)
       ("C-b" helm-previous-page)
       ("C-f" helm-next-page)
       ("C-t" helm-toggle-visible-mark)
       )
     helm-map))
  (cf-bind-helm)

  ;; (setq helm-grep-default-command
  ;;       "ack-grep -Hn --color --smart-case --no-group %e %p %f"
  ;;       helm-grep-default-recurse-command
  ;;       "ack-grep -H --color --smart-case --no-group %e %p %f")
  )

(if (and (package-installed-p 'helm-core)
         (package-installed-p 'helm)
         (package-installed-p 'async))
    (cf-setup-helm)
  (message "helm-core, helm or async not installed"))
#+END_SRC
** Setup projectile
#+BEGIN_SRC emacs-lisp
(defun cf-setup-projectile ()
  (projectile-global-mode)
  (setq projectile-find-dir-includes-top-level t)
  (setq projectile-completion-system 'helm)
  (setq projectile-file-exists-remote-cache-expire nil)
  ;; (setq helm-projectile-fuzzy-match nil)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
  (setq helm-buffers-truncate-lines nil)
  ;; (require 'helm-projectile)
  (condition-case nil
      (helm-projectile-on)
    (error nil))
  (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
  (cf-set-key-bindings
   'define-key
   '(
     ("C-f" projectile-find-file)
     ("C-h" helm-projectile)
     ("C-p" helm-projectile-switch-project)
     ("C-g" helm-projectile-find-file-dwim))
   projectile-command-map))

(if (and (package-installed-p 'projectile)
         (package-installed-p 'helm-projectile))
    (cf-setup-projectile)
  (message "projectile or helm-projectile not installed"))
#+END_SRC
** Setup helm-ag
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(defun cf-setup-helm-ag () )

(if (package-installed-p 'helm-ag)
    (cf-setup-helm-ag)
  (message "helm-ag not installed"))
#+END_SRC
* lisp-interaction-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-interaction-mode-hook
	  '(lambda ()
	     (local-set-key (kbd "C-j") 'next-line)
	     (local-set-key (kbd "C-M-m") 'eval-print-last-sexp)
	     ))
#+END_SRC
* cc-mode
#+BEGIN_SRC emacs-lisp
(defun cf-kill-cc (beg end)
  "If the mark is active, kill region will be used; otherwise, delete
char will be used."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-region beg end)
    (c-electric-delete-forward nil)))

(add-to-list 'auto-mode-alist '("\\.vs$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.fs$" . c++-mode))
(defun cf-semantic-ia-fast-jump-back ()
  "zz from: http://emacser.com/cedet.htm"
  (interactive)
  (if (ring-empty-p (oref semantic-mru-bookmark-ring ring))
      (error "Semantic Bookmark ring is currently empty"))
  (let* ((ring (oref semantic-mru-bookmark-ring ring))
         (alist (semantic-mrub-ring-to-assoc-list ring))
         (first (cdr (car alist))))
    (if (semantic-equivalent-tag-p (oref first tag)
                                   (semantic-current-tag))
        (setq first (cdr (car (cdr alist)))))
    (semantic-mrub-switch-tags first)))
(c-add-style
 "chunfeng-c-style"
 '("gnu"
   (c-basic-offset . 4)
   (c-offsets-alist
    .
    ((innamespace . 0)
     (arglist-intro . 4)
     (arglist-cont-nonempty . 4)
     (arglist-close . 4)
     ))))
(setq c-default-style "chunfeng-c-style")
(defun cf-init-c ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; ("M-l" c-forward-into-nomenclature)
     ;; ("M-h" c-backward-into-nomenclature)
     ;; ("C-M-h" backward-sexp)
     ;; ("C-M-b" c-mark-function)
     ;; ("C-c C-j" senator-next-tag)
     ;; ("C-c C-k" senator-previous-tag)
     ;; ("C-c C-t" semantic-analyze-proto-impl-toggle)
     ;; ("C-c C-f" semantic-ia-fast-jump)
     ;; ("C-c C-b" cf-semantic-ia-fast-jump-back)
     ;; ("C-d" cf-kill-cc)
     ("C-M-a" backward-paragraph)
     ("C-M-e" forward-paragraph)))
  (semantic-mode)
  ;; (c-toggle-auto-state)
  (c-toggle-hungry-state 1))
(add-hook 'c-mode-hook 'cf-init-c)
(add-hook 'c++-mode-hook 'cf-init-c)

(add-hook 'objc-mode-hook 'cf-init-c)
(defun cf-init-objc ()
  (cf-set-key-bindings
   'local-set-key
   '(("C-M-h" nil))))
(add-hook 'objc-mode-hook 'cf-init-objc)
#+END_SRC
* cedet
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
;; cedet

;(cf-install-packages '(cedet))
;(require 'cedet)

(defconst cedet-home "~/.emacs.d/site-byte/cedet")
(defconst cedet-pro-home "~/.emacs.d/cedet-pro")

(setq byte-compile-warnings nil)

(defconst cf-user-include-dirs
  (list ".." "../frame" "../src" "../include"
	"../.." "../../frame" "../../src" "../../include"
	"../../.." "../../../frame" "../../../src" "../../../include"))

(defun cf-semantic-folding-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("C-c C-," semantic-tag-folding-fold-block)
     ("C-c C-." semantic-tag-folding-show-block)
     ("C-c C--" semantic-tag-folding-fold-all)
     ("C-c C-=" semantic-tag-folding-show-all)
     )
   semantic-tag-folding-mode-map))

(defun cf-semantic-tag-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("f" semantic-ia-fast-jump)
     ("b" cf-semantic-ia-fast-jump-back)
     )
   senator-prefix-map))

(defun cf-load-cedet ()
  ""
  (interactive)
  (add-to-list 'load-path (concat cedet-home "/common"))
  (require 'cedet)
  (require 'semantic-ia)
  (require 'semantic-gcc)
  ;;(load-file "~/.emacs.d/site-byte/cedet/common/cedet.el")
  (semantic-load-enable-code-helpers)
  (semantic-load-enable-minimum-features)
  ;;(semantic-load-enable-guady-code-helpers)
  ;;(semantic-load-enable-excessive-code-helpers)
  ;;(semantic-load-enable-semantic-debugging-helpers)
  (require 'semanticdb)
  (global-semanticdb-minor-mode 1)
  ;;(require 'semanticdb-global)
  ;;(semanticdb-enable-gnu-global-databases 'c-mode)
  ;;(semanticdb-enable-gnu-global-databases 'c++-mode)
  (global-ede-mode 1)
  (let ((include-dirs cf-user-include-dirs))
    (if (string-equal system-type "windows-nt")
	(setq include-dirs
	      (append include-dirs cf-system-include-dirs)))
    (mapc (lambda (dir)
	    (semantic-add-system-include dir 'c++-mode)
	    (semantic-add-system-include dir 'c-mode))
	  include-dirs))
  (require 'semantic-tag-folding nil 'noerror)
  (global-semantic-tag-folding-mode 1)
  (cf-semantic-folding-key-binding)
  (cf-semantic-tag-key-binding)
  (if (file-exists-p cedet-pro-home)
      (mapc 'load
            (directory-files cedet-pro-home t
                             "^[a-zA-Z0-9].*.el$"))))

;; (if (file-exists-p cedet-home)
;;     (cf-load-cedet))
#+END_SRC
* cmake
#+BEGIN_SRC emacs-lisp
(autoload 'cmake-mode "cmake-mode" "Cmake Mode" t)
(add-to-list 'auto-mode-alist '("CMakeLists\\.txt$" . cmake-mode))
(add-to-list 'auto-mode-alist '("\\.cmake$" . cmake-mode))
#+END_SRC
* company
Use [[http://company-mode.github.io/][company-mode]], a modular in-buffer completion framework for Emacs.
** init
#+BEGIN_SRC emacs-lisp
(defun cf-setup-company ()
  ;; Init
  (add-hook 'after-init-hook #'global-company-mode)
  ;; Reduce completion menu time delay to minimum.
  (customize-set-variable 'company-idle-delay 0)
  ;; key
  (with-eval-after-load 'company
    ;; select completion
    ;; (cf-set-key-bindings
    ;;  'define-key
    ;;  '(
    ;;    ("M-n" company-select-next)
    ;;    ("M-p" company-select-previous)
    ;;
    ;;    ("<RET>" company-complete-selection)
    ;;    ("<TAB>" company-complete-common)
    ;;    )
    ;;  company-active-map)
    (cf-set-key-bindings
     'global-set-key
     '(("M-n" company-complete)))
    )
  ;; Show quick-access numbers of completion options.
  (customize-set-variable 'company-show-numbers t)
  ;; Align annotations.
  (customize-set-variable 'company-tooltip-align-annotations t)
  (customize-set-variable 'company-dabbrev-downcase nil))
(if (package-installed-p 'company)
    (cf-setup-company)
  (message "company mode not installed"))
#+END_SRC
** company-quickhelp
Use [[https://github.com/expez/company-quickhelp][company-quickhelp]], which shows a documentation pop-up during
=company-mode= completion.
#+BEGIN_SRC emacs-lisp :tangle no
(defun cf-setup-company-quickhelp ()
  (company-quickhelp-mode t)
  ;; Do not show pop-up automatically
  (customize-set-variable 'company-quickhelp-delay nil)
  ;; Define binding for showing pop-up manually in company-active-map instead of
  ;; company-quickhelp-mode-map; this activates it only when we want completion.
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "C-c h") #'company-quickhelp-manual-begin)))
(if (and (package-installed-p 'company)
         (package-installed-p 'company-quickhelp-mode))
    (cf-setup-company-quickhelp)
  (message "company or company-quickhelper not installed"))
#+END_SRC
** misc
There's also ~company-show-doc-buffer~, which is built into
~company-mode-map~, but the selections disappear when the doc buffer
appears (maybe it just doesn't play nice with =popwin=?). Furthermore,
it's easier to read the documentation when it's right next to the
candidate.
** company-c-headers
- https://github.com/randomphrase/company-c-headers
- This library enables the completion of C/C++ header file names using
  Company mode
#+BEGIN_SRC emacs-lisp
(defun cf-setup-company-c-headers ()
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-c-headers)))
(if (package-installed-p 'company-c-headers)
    (cf-setup-company-c-headers)
  (message "company-c-headers not installed"))
#+END_SRC
* dired
** display in other window or copy selected
#+BEGIN_SRC emacs-lisp
(defun cf-disply-other-copy (beg end)
  "If the mark is active, copy region will be used; otherwise,
open a new line."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-ring-save beg end)
    (dired-display-file)))
#+END_SRC
** key binding
#+BEGIN_SRC emacs-lisp
(defun cf-dired-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("j" dired-next-line)
     ("k" dired-previous-line)
     ("r" revert-buffer)
     ("C-t" set-mark-command)
     ("C-o" cf-disply-other-copy))
   dired-mode-map))
(add-hook 'dired-mode-hook 'cf-dired-key-binding)
#+END_SRC
** Listing Parameters
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alnoh")
(defun cf-set-ls (parameter)
  "Set ls parameter in dired mode"
  (interactive "s")
  (setq dired-listing-switches parameter))
#+END_SRC
* expand-region
#+BEGIN_SRC emacs-lisp
(defun cf-expand-region-setup ()
  (cf-set-key-bindings
   'global-set-key
   '(
     ("C-=" er/expand-region)
     ("M-t" er/expand-region)
     )))

(if (package-installed-p 'expand-region)
    (cf-expand-region-setup)
  (message "expand-region not installed"))
#+END_SRC
* flycheck
#+BEGIN_SRC emacs-lisp
(defvar flycheck-global-modes)

(defun cf-setup-flycheck ()
  (require 'flycheck)
  (add-hook 'after-init-hook 'global-flycheck-mode)
  (setq flycheck-global-modes
        '(emacs-lisp-mode js-mode js2-mode json-mode web-mode))
  (setq-default flycheck-disabled-checkers
                '(emacs-lisp-checkdoc))
  ;; jsx setting
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlint)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
)

(if (package-installed-p 'flycheck)
    (cf-setup-flycheck)
  (message "flycheck not installed"))
#+END_SRC
** functions
- =flycheck-verify-setup= (=C-c ! v=): to check whether flycheck setup
  is complete
- (=C-c ! n=) & (=C-c ! p=): to jump back and forth between erroneous
  places
- (=C-c ! l=): to pop up a list of all errors in the current buffer
- =flycheck-select-checker=: to use this as the 1st for current buffer
- =flycheck-buffer= (=C-c ! c=): to check manually
- =[var]flycheck-checker=: checker used for current buffer
* Folding
** Main Code
#+BEGIN_SRC emacs-lisp
(setq default-label 'cycle-fold)

(defun goto-list (count depth)
  (condition-case ex
      (goto-char (scan-lists (point) count depth))
    (error
      (message "Error in goto-list: %s" ex)
      nil)))

(defun scan-lists-safe (from count depth &optional default)
  (condition-case ex
      (scan-lists from count depth)
    (error
      (message "Error in scan-lists: %s" ex)
      default)))

(defun get-bol (pos)
  (save-excursion (goto-char (or pos (point)))
                  (beginning-of-line)
                  (point)))

(defun get-eol (pos)
  (save-excursion (goto-char (or pos (point)))
                  (end-of-line)
                  (point)))

(defun my-filter (condp lst)
  (delq nil
        (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

(defun label->tag (label)
  (intern (concat "tag-" (symbol-name (or label default-label)))))

(defun create-overlay (start end &optional label val)
  (let ((o (make-overlay start end))
        (tag (label->tag label)))
    ;; (message "tag: %s" tag)
    (if val
        (overlay-put o tag val)
      (overlay-put o tag t))
    (overlay-put o 'evaporate t)
    (overlay-put o 'invisible t)
    (overlay-put o 'display `(:string "..."))
    (overlay-put
     o 'isearch-open-invisible
     (lambda (ov)
       (message "open invisible")
       (delete-overlay ov)))
    (overlay-put
     o 'isearch-open-invisible-temporary
     (lambda (ov invisible)
       (overlay-put ov 'invisible invisible)
       (overlay-put ov 'display (and invisible `(:string "...")))))
    o))

(defun get-overlays (start end &optional label val)
  (let ((tag (label->tag label))
        (os (overlays-in start end)))
    (if (null tag)
        os
      (my-filter (lambda (o)
                   (if (null val)
                       (overlay-get o tag)
                     (equal (overlay-get o tag) val)))
                 os))))

(defun delete-overlays (start end &optional label val)
  (dolist (o (get-overlays start end label val))
    (delete-overlay o)))

(defun cal-fold-region-at (&optional pos)
  (interactive)
  (let* ((start (or pos (point)))
         (eol (get-eol start))
         (end (scan-lists start 1 0)))
    (if (> (- end eol) 1)
        (list (cons :start eol)
              (cons :end (1- end))))))

(defun cal-fold-region-line (&optional pos)
  (interactive)
  (let* ((p (or pos (point)))
         (bol (get-bol p))
         (eol (get-eol p))
         (end (scan-lists-safe bol 1 0 (min (1+ bol) eol))))
    (while (< end eol)
      (setq end (scan-lists-safe end 1 0 (min (1+ end) eol))))
    (if (> end eol)
        (cal-fold-region-at (scan-lists end -1 0)))))

(defun current-fold-state (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (let* ((start (cdr (assoc :start range)))
               (end (cdr (assoc :end range)))
               (os (get-overlays start end)))
          ;; (message "%s %s %s" start end os)
          (if os
              (if (and (null (cdr os))
                       (equal start (overlay-start (car os)))
                       (equal end (overlay-end (car os))))
                  :folded
                :mis-folded)
            :unfolded))
      :no-fold)))

(defun fold-at (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-at pos)))
    (if range
        (create-overlay (cdr (assoc :start range))
                        (cdr (assoc :end range))))))

(defun fold-line (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (create-overlay (cdr (assoc :start range))
                        (cdr (assoc :end range))))))

(defun fold-at-end (&optional pos)
  (interactive)
  (save-excursion
    (goto-list -1 0)
    (fold-at (point))))

(defun unfold-line (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (delete-overlays (cdr (assoc :start range))
                         (cdr (assoc :end range))))))

(defun fold-children (&optional pos)
  (interactive)
  (save-excursion
    (let ((range (cal-fold-region-line pos)))
      (when range
        (goto-char (cdr (assoc :start range)))
        (while (goto-list 1 0)
          (fold-at-end))))))

(defun toggle-fold-line (&optional pos)
  (interactive)
  (let ((status (current-fold-state)))
    (cond
     ((eq status :no-fold) nil)
     ((eq status :unfolded) (fold-line pos))
     ((eq status :mis-folded)
      (unfold-line pos)
      (unless (eq last-command 'toggle-fold-line)
        (fold-line pos)))
     ((eq status :folded)
      (unfold-line pos)
      (fold-children pos))
     (t :default))))

(defun toggle-fold-all ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (if (and (eq last-command 'toggle-fold-all)
             (get-overlays (point-min) (point-max)))
        (delete-overlays (point-min) (point-max))
      (progn (delete-overlays (point-min) (point-max))
             (while (goto-list 1 0)
               (fold-at-end))))))
#+END_SRC
** Key Binding
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(("C-<tab>" toggle-fold-line)
   ("C-S-<tab>" toggle-fold-all)))
#+END_SRC
** Example
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
'(a b c
    (d
     e)
    (f g)
    (h
     (i j))
    ((k l
        (m n)
        (p q) (r s))
     o))
#+END_SRC
** Test
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(message "****************** start *******************")
(message "label->tag: %s" (label->tag 'test))
(message "label->tag === 'tag-test: %s" (eq (label->tag 'test) 'tag-test))
(message "delete-overlays: %s" (delete-overlays 1 100 'test))
(message "create-overlay: %s" (create-overlay 1 10 'test))
(message "get-overlays: %s" (get-overlays 1 100 'test))
(message "delete-overlays: %s" (delete-overlays 1 100 'test))
(message "get-overlays: %s" (get-overlays 1 100 'test))
(message "****************** end *******************")

(overlay-put o 'face `(:background "grey50"))
(overlay-put o 'face nil)
(overlay-put o 'display `(:string "(...)"))
(overlay-put o 'display nil)
#+END_SRC
** Todo
- minor mode
- 'helm-after-action-hook
- 'helm-after-persistent-action-hook
- 'occur-mode-find-occurrence-hook
- bug of [{\n},{\n},{\n}]
- lightweight-macro
* Graphviz Dot Mode
#+BEGIN_SRC emacs-lisp
(defun cf-graphviz-mode ()
  ""
  (setq graphviz-dot-indent-width 2)
  ;; (setq graphviz-dot-auto-indent-on-semi nil)
  )
(add-hook 'graphviz-dot-mode-hook 'cf-graphviz-mode)
#+END_SRC
* highlight-indentation
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(defun cf-highlight-indetation-setup ()
  ;; (autoload 'js3-mode "js3-mode" nil t)
  (require 'highlight-indentation)
  ;; (setq highlight-indent-offset 2)
  (if (display-graphic-p)
      (set-face-background
       'highlight-indentation-face "grey20"))
  (if (display-graphic-p)
      (set-face-background
       'highlight-indentation-current-column-face "grey12")))

(if (package-installed-p 'highlight-indentation)
    (cf-highlight-indetation-setup)
  (message "highlight-indetation not installed"))
#+END_SRC
* html
** html-mode
#+BEGIN_SRC emacs-lisp
;; (add-to-list 'auto-mode-alist '("\\.hbs$" . html-mode))
(defun cf-html-func ()
  (cf-set-key-bindings
   'local-set-key
   '(("C-c C-x -" html-horizontal-rule)
     ("C-c C-x c" html-checkboxes)
     ("C-c C-x h" html-href-anchor)
     ("C-c C-x i" html-image)
     ("C-c C-x l" html-list-item)
     ("C-c C-x n" html-name-anchor)
     ("C-c C-x o" html-ordered-list)
     ("C-c C-x r" html-radio-buttons)
     ("C-c C-x u" html-unordered-list))
   ;; html-mode-map
   )
  (cf-set-key-bindings
   'define-key
   '(("C-c C-/" sgml-close-tag))
   sgml-mode-map))
(add-hook 'html-mode-hook 'cf-html-func)
#+END_SRC
** nxml-mode
#+BEGIN_SRC emacs-lisp
(defun cf-nxml-func()
  (cf-set-key-bindings
   'define-key
   '(
     ("C-c C-e" sgml-close-tag)
     ("M-h" nil))
   nxml-mode-map))
(add-hook 'nxml-mode-hook 'cf-nxml-func)
#+END_SRC
** web-mode
#+BEGIN_SRC emacs-lisp
(defun cf-web-mode-setup ()
  (add-to-list 'auto-mode-alist '("\\.jsx" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.hbs$" . web-mode))
  (defun cf-web-mode-func()
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-style-padding 2)
    (setq web-mode-script-padding 2)
    (setq web-mode-block-padding 0)
    (set-face-attribute 'web-mode-html-tag-face nil :foreground "SkyBlue1")
    (setq web-mode-enable-current-element-highlight t)
    (set-face-attribute 'web-mode-current-element-highlight-face nil :background "honeydew4")
    (setq web-mode-enable-current-column-highlight nil)
    (setq web-mode-enable-sexp-functions t)
    ;; (setq web-mode-enable-auto-quoting nil)
    ;; (setq web-mode-enable-auto-indentation nil)
    (cf-set-key-bindings
     'define-key
     '(
       ("C-t" nil)
       ("M-t" nil)
       ;; ("M-t" web-mode-mark-and-expand)
       ("C-c C-e C-c" web-mode-element-close)
       ("C-c C-e C-/" web-mode-element-close)
       )
     web-mode-map))
  (add-hook 'web-mode-hook 'cf-web-mode-func))
(if (package-installed-p 'web-mode)
    (cf-web-mode-setup)
  (message "web-mode not installed"))
#+END_SRC
* imenu
#+BEGIN_SRC emacs-lisp
(setq imenu-auto-rescan nil)
#+END_SRC
* java
#+BEGIN_SRC emacs-lisp
(defun cf-java-func ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-M-h" backward-sexp)
     ("C-M-b" c-mark-function)
     ("C-M-a" nil)
     ("C-M-e" nil)
     ("M-k" c-beginning-of-defun)
     ("M-j" c-end-of-defun)
     ("C-d" nil)
     )))
(add-hook 'java-mode-hook 'cf-java-func)
#+END_SRC
* js
** node-modules-path-setup
From: https://github.com/codesuki/add-node-modules-path
#+BEGIN_SRC emacs-lisp
(defun cf-node-modules-path-setup ()
  (defvar add-node-modules-path-debug nil
    "Enable verbose output when non nil.")

  (defun add-node-modules-path ()
    "Search the current buffer's parent directories for `node_modules/.bin`.
If it's found, then add it to the `exec-path'."
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (path (and root
                      (expand-file-name "node_modules/.bin/" root))))
      (if root
          (progn
            (make-local-variable 'exec-path)
            (add-to-list 'exec-path path)
            (when add-node-modules-path-debug
              (message (concat "added " path  " to exec-path"))))
        (when add-node-modules-path-debug
          (message (concat "node_modules not found in " root))))))
  (eval-after-load 'js-mode
    '(add-hook 'js-mode-hook #'add-node-modules-path))
  (eval-after-load 'js2-mode
  '(add-hook 'js2-mode-hook #'add-node-modules-path))
  (eval-after-load 'web-mode
    '(add-hook 'web-mode-hook #'add-node-modules-path)))
(cf-node-modules-path-setup)
#+END_SRC
** js-mode
#+BEGIN_SRC emacs-lisp
(defun cf-js-setup ()
  (setq-default js-indent-level 2))
(cf-js-setup)
#+END_SRC
** js2-mode
#+BEGIN_SRC emacs-lisp
(defun cf-js2-setup ()
  ;; js2-mode-hide-comments
  ;; js2-mode-hide-element
  ;; js2-mode-hide-functions
  ;; js2-mode-hide-warnings-and-errors
  ;;
  ;; js2-mode-show-all
  ;; js2-mode-show-comments
  ;; js2-mode-show-element
  ;; js2-mode-show-functions
  ;; js2-mode-show-node
  ;;
  ;; js2-mode-toggle-element "C-c C-o"
  ;; js2-mode-toggle-hide-comments
  ;; js2-mode-toggle-hide-functions
  ;; js2-mode-toggle-warnings-and-errors
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
  (setq-default js-indent-level 2)
  ;; this will hide errors & warnings
  (setq-default js2-mode-show-parse-errors nil)
  (setq-default js2-mode-show-strict-warnings nil)
  (setq-default js2-bounce-indent-p t)
  ;; (setq-default js2-strict-inconsistent-return-warning nil)
  (defun cf-init-js ()
    ;; (electric-indent-mode -1)
    (cf-set-key-bindings
     'local-set-key
     '()))
  (add-hook 'js2-mode-hook 'cf-init-js))

(if (package-installed-p 'js2-mode)
    (cf-js2-setup)
  (message "js2-mode not installed"))
#+END_SRC
** js3-mode
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(defun cf-js3-setup ()
  (autoload 'js3-mode "js3-mode" nil t)
  (eval-after-load "js3-mode"
    (add-hook 'js3-mode-hook
              (lambda ()
                (setq ;; js3-auto-indent-p nil
                      js3-curly-indent-offset 0
                      js3-enter-indents-newline t
                      js3-expr-indent-offset 2
                      js3-indent-on-enter-key t
                      js3-lazy-commas t
                      js3-lazy-dots t
                      js3-lazy-operators t
                      js3-paren-indent-offset 2
                      js3-square-indent-offset 4)
                (auto-complete-mode 1))))
  (add-to-list 'auto-mode-alist '("\\.js$" . js3-mode)))
(if (package-installed-p 'js3-mode)
    (cf-js3-setup)
  (message "js3-mode not installed"))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
(defun cf-json-setup ())
(if (package-installed-p 'json-mode)
    (cf-json-setup)
  (message "json-mode not installed"))
#+END_SRC
* jump (avy)
#+BEGIN_SRC emacs-lisp
(defun cf-setup-avy ()
  (cf-set-key-bindings
   'global-set-key
   '(
     ("M-f" nil)

     ("M-f M-f" avy-goto-word-1)
     ("M-f M-g" avy-goto-word-0)

     ("M-f M-j" avy-goto-char-2)
     ("M-f M-k" avy-goto-char)

     ("M-f M-d" avy-goto-char-in-line)

     ("M-f M-l" avy-goto-line)
     )))

(if (package-installed-p 'avy)
    (cf-setup-avy)
  (message "avy not installed"))
#+END_SRC
* latex
** tex-mode
#+BEGIN_SRC emacs-lisp
(defun cf-init-latex-mode ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-j" next-line)
     ;;("C-n" tex-terminate-paragraph)
     ("C-c C-o" nil)
     ("C-c C-b" latex-insert-block)))
  ;; (setq tex-command "xelatex")
  (setq tex-dvi-print-command "dvipdf")
  (setq tex-dvi-view-command
	'(cond
	  ((eq window-system 'x) "xdvi")
	  ((eq window-system 'w32) "yap")
	  ((eq window-system 'ns) "xdvi")
	  (t "dvi3tty * | cat -s")))
  (outline-minor-mode)
  )
(add-hook 'tex-mode-hook 'cf-init-latex-mode)
#+END_SRC
** bibtex-mode
#+BEGIN_SRC emacs-lisp
(defun cf-bibtex-mode ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-j" nil)
     ("C-c C-j" bibtex-pop-next)
     ("C-c C-k" bibtex-pop-previous)
     ("C-M-h" nil)
     ("C-M-l" nil)
     ("C-M-b" bibtex-mark-entry)
     ("M-n" ispell-complete-word)
     ("M-m" ispell-complete-word)
     )
   )
  (outline-minor-mode)
  )
(add-hook 'bibtex-mode-hook 'cf-bibtex-mode)
#+END_SRC
* lisp
** paredit
#+BEGIN_SRC emacs-lisp
(defun cf-paredit-setup ()

  (dolist (mode '(scheme emacs-lisp lisp clojure clojurescript))
    ;; (when (> (display-color-cells) 8)
    ;;   (font-lock-add-keywords (intern (concat (symbol-name mode) "-mode"))
    ;;                           '(("(\\|)" . 'esk-paren-face))))
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
              'paredit-mode))

  (defun cf-paredit-kill (beg end)
    "If the mark is active, kill region will be used; otherwise, delete
char will be used."
    (interactive (list (point) (mark)))
    (if mark-active
        (kill-region beg end)
      (paredit-forward-delete 1)))

  (defun cf-paredit-key ()
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("C-j" next-line)
       ;; ("C-k" previous-line)
       ;; ("C-f" paredit-kill)
       ;; ("C-n" paredit-newline)
       ;; ("C-d" cf-paredit-kill)
       ;; ("C-d" nil)

       ;; ("C-M-b" nil)
       ;; ("C-M-f" nil)
       ;; ("C-M-h" paredit-backward)
       ;; ("C-M-l" paredit-forward)
       ;; ("C-M-j" paredit-forward-up)
       ;; ("C-M-k" paredit-backward-down)

       ;; ("(" nil)
       ;; (")" nil)
       ;; ("[" nil)
       ;; ("]" nil)
       ;; ("{" nil)
       ;; ("}" nil)
       ;; ("\"" nil)
       )
     paredit-mode-map))

  (eval-after-load 'paredit '(cf-paredit-key)))

(if (package-installed-p 'paredit)
    (cf-paredit-setup)
  (message "paredit not installed"))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
(defun cf-clojure-mode-setup ()
  ;; (add-hook 'nrepl-mode-hook 'subword-mode)
  ;; (add-hook 'nrepl-mode-hook 'rainbow-delimiters-mode)

  (defun cf-clojure-match-next-def ()
    "Scans the buffer backwards for the next top-level definition.
Called by `imenu--generic-function'."
    (when (re-search-backward "^\\s *(def\\S *[ \n\t]+" nil t)
      (save-excursion
        (goto-char (match-end 0))
        (when (looking-at "#?\\^")
          (let (forward-sexp-function) ; using the built-in one
            (forward-sexp)))           ; skip the metadata
        (re-search-forward "[^ \n\t)]+"))))

  (defun cf-clojure-mode-func ()
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("{" nil)
       ;; ("}" nil)
       )
     clojure-mode-map)
    (setq-local imenu-create-index-function
                (lambda ()
                  (imenu--generic-function
                   '((nil cf-clojure-match-next-def 0))))))
  (add-hook 'clojure-mode-hook 'cf-clojure-mode-func))

(if (package-installed-p 'clojure-mode)
    (cf-clojure-mode-setup)
  (message "clojure-mode not installed"))
#+END_SRC
* multiple-cursors
#+BEGIN_SRC emacs-lisp
(defun cf-multiple-cursors-setup ()
  (setq mc/list-file (cf-path "mc-list.el"))
  (setq mc/always-run-for-all t)
  (cf-set-key-bindings
   'global-set-key
   '(
     ("C-S-c C-S-c" mc/edit-lines)
     ("C-M-_" mc/mark-previous-like-this)
     ("C-M-+" mc/mark-next-like-this)
     ("C-M-|" mc/mark-all-like-this)
     ("C-S-c C-<" mc/mark-all-like-this)
     ("C-S-c C-S-r" set-rectangular-region-anchor)
     ("C-S-c C-S-k" set-rectangular-region-anchor))))

(if (package-installed-p 'multiple-cursors)
    (cf-multiple-cursors-setup)
  (message "multiple-cursors not installed"))
#+END_SRC
* markdown
#+BEGIN_SRC emacs-lisp
(defun cf-setup-md ()
  (defun cf-md-mode-hook ()
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("C-c C-j" markdown-next-visible-heading)
       ;; ("C-c C-k" markdown-previous-visible-heading)
       ;; ("C-c C-l" markdown-forward-same-level)
       ;; ("C-c C-h" markdown-backward-same-level)
       ;; ("C-c C-u" markdown-up-heading)
       )
     markdown-mode-map))
  (add-hook 'markdown-mode-hook 'cf-md-mode-hook))

(if (package-installed-p 'markdown-mode)
    (cf-setup-md)
  (message "md not installed"))
#+END_SRC
* outline
#+BEGIN_SRC emacs-lisp
(setq outline-minor-mode-prefix (kbd "C-c C-o"))
(defun cf-outline-minor-mode ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-c C-=" show-all)
     ("C-c C--" hide-body)
     ("C-c C-[" hide-subtree)
     ("C-c C-]" show-subtree)
     ("C-c C-," hide-entry)
     ("C-c C-." show-entry)
     ;; ("C-c C-j" outline-next-visible-heading)
     ;; ("C-c C-k" outline-previous-visible-heading)
     ;; ("C-c C-h" outline-backward-same-level)
     ;; ("C-c C-l" outline-forward-same-level)
     ;; ("C-c C-u" outline-up-heading)
     )
   )
  )
(add-hook 'outline-minor-mode-hook 'cf-outline-minor-mode)
#+END_SRC
* python
#+BEGIN_SRC emacs-lisp
(defun cf-python-setup ()
  (autoload 'python-mode "python-mode" "Python Mode." t)
  (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))

  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")

  (defun cf-init-python ()
    (cf-set-key-bindings
     'local-set-key
     '())
    (cf-set-key-bindings
     'define-key
     '(;; ("C-j" nil)
       ;; ("C-n" py-newline-and-indent)
       ;; ("C-m" nil)
       ;; ("C-M-h" nil)
       ;; ("C-M-b" py-mark-def-or-class)
       ;; ("M-j" py-forward-block-or-clause)
       ;; ("M-k" py-backward-block-or-clause)
       ;; ("C-M-j" py-forward-block-or-clause)
       ;; ("C-M-k" py-backward-block-or-clause)
       ;; ("C-M-a" nil)
       ;; ("C-M-e" nil)
       ;; ("C-c C-v" nil)
       ;; ("C-c C-x" nil)
       ;; ("C-c C-m" nil)
       ;; ("C-c C-v C-l" py-shift-right)
       ;; ("C-c C-v C-h" py-shift-left)
       ;; ("C-c C-i C-l" py-shift-right)
       ;; ("C-c C-i C-h" py-shift-left)
       ;; ("C-c C-x C-l" py-shift-block-or-clause-right)
       ;; ("C-c C-x C-h" py-shift-block-or-clause-left)
       )
     python-mode-map)
    ;; (subword-mode)
    (setq python-indent-offset 4)
    ;; (c-toggle-auto-state)
    (c-toggle-hungry-state 1)
    (highlight-indentation-mode)
    (highlight-indentation-current-column-mode)
    ;; (setq py-complete-function nil)
    (company-mode -1) ;; disable auto complete
    )
  (add-hook 'python-mode-hook 'cf-init-python))

;; https://www.seas.upenn.edu/~chaoliu/2017/09/01/python-programming-in-emacs/
(defun cf-jedi-setup ()
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook 'jedi:setup)
  (add-hook 'python-mode-hook 'jedi:ac-setup))

(if (package-installed-p 'python-mode)
    (cf-python-setup)
  (message "python-mode not installed"))
;; (if (package-installed-p 'company-jedi)
;;     (cf-jedi-setup)
;;   (message "company-jedi not installed"))
#+END_SRC
* ruby
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("RakeFile" . ruby-mode))
(defun cf-init-ruby ()
  (cf-set-key-bindings
   'local-set-key
   '())
  ;; (c-toggle-auto-state)
  (c-toggle-hungry-state 1))
(add-hook 'ruby-mode-hook 'cf-init-ruby)
#+END_SRC
* scss
#+BEGIN_SRC emacs-lisp
(defun cf-scss-mode-setup ()
  (setq scss-compile-at-save nil)
  (defun cf-init-scss ()
    (message "init-scss")
    (cf-set-key-bindings
     'local-set-key
     '())
    (setq css-indent-offset 2))
  (add-hook 'scss-mode-hook 'cf-init-scss))

(if (package-installed-p 'scss-mode)
    (cf-scss-mode-setup)
  (message "scss-mode not installed"))
#+END_SRC
* shell
** sh mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/\\.bash_[^/]*\\'" . sh-mode))

(defun cf-shell-kill (beg end)
  "If the mark is active, kill region will be used; otherwise, delete
char will be used."
  (interactive (list (point) (mark)))
  (if mark-active
      (kill-region beg end)
    (comint-delchar-or-maybe-eof 1)))

;; sh mode
(defun cf-sh-mode-hook-func ()
  (cf-set-key-bindings
   'define-key
   '()
   sh-mode-map))
(add-hook 'sh-mode-hook 'cf-sh-mode-hook-func)
#+END_SRC
** shell mode
#+BEGIN_SRC emacs-lisp
(defun cf-shell-mode-hook-func ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-d" cf-shell-kill)
     ("C-M-l" nil)
     ;;("C-c h" comint-history-isearch-backward)
     ;;("M-s" comint-history-isearch-search)
     ("C-c h" comint-history-isearch-backward-regexp)

     ("M-n" comint-next-input)
     ("M-p" comint-previous-input)
     ;; ("M-h" backward-word)
     ("C-M-n" comint-next-matching-input-from-input)
     ("C-M-p" comint-previous-matching-input-from-input)
     ;; ("M-n" nil)
     ;; ("M-p" nil)

     ("C-c C-b" shell-backward-command)
     ("C-c C-f" shell-forward-command)
     ("C-c C-n" comint-next-prompt)
     ("C-c C-p" comint-previous-prompt)

     )
   ;;shell-mode-map
   )
  (linum-mode 0))
(add-hook 'shell-mode-hook 'cf-shell-mode-hook-func)
#+END_SRC
** term mode
#+BEGIN_SRC emacs-lisp
(defun cf-term-mode-hook-func ()
  (linum-mode 0)
  (setq-local scroll-margin 0)
  (cf-set-key-bindings
   'local-set-key
   '(
     ))
  (cf-set-key-bindings
   'define-key
   '(("C-b" scroll-up-command)
     ("C-f" scroll-down)
     ("C-y" term-paste)
     ("s-v" term-paste)
     ("M-x" nil)
     ("C-u" universal-argument)
     ("C-c C-y" term-interrupt-subjob)
     ("C-o" cf-open-copy))
   term-raw-map))
(add-hook 'term-mode-hook 'cf-term-mode-hook-func)
#+END_SRC
** tm function
#+BEGIN_SRC emacs-lisp
(defun tm ()
  "start-ansi-term"
  (interactive)
  (let (bf-name
        (sh-name "/bin/bash"))
    (if t ;;current-prefix-arg
        (setq bf-name
              (read-from-minibuffer "Buffer (*tm*): " bf-name)))
    (if (or (not bf-name)
            (= (length bf-name) 0))
        (setq bf-name "*tm*"))
    (setq bf-name (generate-new-buffer-name bf-name))
    (ansi-term sh-name)
    (rename-buffer bf-name)))
#+END_SRC
** sh function
#+BEGIN_SRC emacs-lisp
(defun sh ()
  "start-shell"
  (interactive)
  (let (bf-name)
    (setq bf-name
          (read-from-minibuffer "Buffer (*shell*): " bf-name))
    (if (or (not bf-name)
            (= (length bf-name) 0))
        (shell)
      (shell bf-name))))
#+END_SRC
* speedbar
#+BEGIN_SRC emacs-lisp
(defun cf-speedbar-key-hook-func ()
  (cf-set-key-bindings
   'define-key
   '(
    ;; ("j" speedbar-next)
    ;; ("k" speedbar-prev)
    ;; ("C-M-j" speedbar-forward-list)
    ;; ("C-M-k" speedbar-backward-list)
    ;; ("M-j" speedbar-restricted-next)
    ;; ("M-k" speedbar-restricted-prev)
    )
   speedbar-key-map)
  (cf-set-key-bindings
   'define-key
   '(
     ("k" speedbar-prev)
     ("d" speedbar-buffer-kill-buffer)
     )
   speedbar-buffers-key-map)
  (linum-mode 0))
(add-hook 'speedbar-reconfigure-keymaps-hook
          'cf-speedbar-key-hook-func)
(eval-after-load "speedbar-mode"
  '(progn
     (linum-mode 0)))
#+END_SRC
* spell
#+BEGIN_SRC emacs-lisp
(setq-default ispell-program-name "aspell")
#+END_SRC
* tramp
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(setq tramp-default-method "scp")
;;(custom-set-variables '(tramp-verbose 6))
(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
#+END_SRC
* view
#+BEGIN_SRC emacs-lisp
(defun cf-view-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ;; ("C-j" View-scroll-line-forward)
     ("C-j" nil)
     )
   view-mode-map
   )
  )
(add-hook 'view-mode-hook 'cf-view-key-binding)
#+END_SRC
* asm
#+BEGIN_SRC emacs-lisp
(defun cf-asm-setup ()
  ;; (setq-default js2-strict-inconsistent-return-warning nil)
  (defun cf-init-asm ()
    (cf-set-key-bindings
     'local-set-key
     '(
       ;; ("C-j" next-line)
       ;; ("RET" newline)
       )))
  (add-hook 'asm-mode-hook 'cf-init-asm))
(cf-asm-setup)
#+END_SRC
* prettier
- https://github.com/prettier/prettier-emacs
- https://prettier.io/
#+BEGIN_SRC emacs-lisp
(defun cf-setup-prettier ()
  ;; (add-hook 'js2-mode-hook
  ;;           #'(lambda ()
  ;;               (if (executable-find "prettier")
  ;;                   (prettier-js-mode))))
  ;; (add-hook 'web-mode-hook
  ;;           #'(lambda ()
  ;;               (if (and (executable-find "prettier")
  ;;                        (buffer-file-name)
  ;;                        (string-match "\\.jsx?\\'" buffer-file-name))
  ;;                   (prettier-js-mode))))
  ;; (add-hook 'yaml-mode-hook
  ;;           #'(lambda ()
  ;;               (if (executable-find "prettier")
  ;;                   (prettier-js-mode))))
  (global-set-key [f8] 'prettier-js)
  )
(if (package-installed-p 'prettier-js)
    (cf-setup-prettier)
  (message "prettier-js not installed"))
#+END_SRC
* Find Library File
Functions and bindings to make library files more easy to examine and
change.
#+BEGIN_SRC emacs-lisp
(defun find-library-file (library)
  "Takes a single argument LIBRARY, being a library file to search for.
Searches for LIBRARY directly (in case relative to current directory,
or absolute) and then searches directories in load-path in order.  It
will test LIBRARY with no added extension, then with .el, and finally
with .elc.  If a file is found in the search, it is visited.  If none
is found, an error is signaled.  Note that order of extension searching
is reversed from that of the load function."
  (interactive "sFind library file: ")
  (let ((path (cons "" load-path)) exact match elc test found)
    (while (and (not match) path)
      (setq test (concat (car path) "/" library)
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq path (cons "" load-path))
    (or match
        (while (and (not elc) path)
          (setq test (concat (car path) "/" library ".elc")
                elc (if (condition-case nil
                            (file-readable-p test)
                          (error nil))
                        test)
                path (cdr path))))
    (setq path (cons "" load-path))
    (while (and (not match) path)
      (setq test (concat (car path) "/" library ".el")
            match (if (condition-case nil
                          (file-readable-p test)
                        (error nil))
                      test)
            path (cdr path)))
    (setq found (or match elc))
    (if found
        (progn
          (find-file found)
          (and match elc
               (message "(library file %s exists)" elc)
               (sit-for 1))
          (message "Found library file %s" found))
      (error "Library file \"%s\" not found." library))))

(define-key ctl-x-4-map "l" 'find-library-file)
(define-key ctl-x-4-map "r" 'byte-recompile-directory)
#+END_SRC
* Todo List
** TODO read a list of people with nice emacs config files
- https://github.com/zamansky/emacs.dz
** TODO toc-org
- https://github.com/snosov1/toc-org
** TODO magit
* License
My Emacs configurations written in Org mode.

Copyright (c) 2013-2018 Chunfeng Dai

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
