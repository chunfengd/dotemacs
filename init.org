#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :comments org

#+TITLE: Emacs Configuration File
#+AUTHOR: Chunfeng Dai

# Adapted from Lars Tveito's and Tianxiang Xiong's excellent
# configuration files.
# See:
#   - https://github.com/larstvei/dot-emacs/blob/master/init.org
#   - https://github.com/xiongtx/.emacs.d/blob/master/init.org

* Table of Contents                                                     :TOC:
 - [[#introduction][Introduction]]
   - [[#other-reference][other reference]]
 - [[#dotemacs-path][Dotemacs Path]]
   - [[#define-cf-path][Define =cf-path=]]
   - [[#extra-load-path][Extra load path]]
 - [[#how-to-install][How to Install]]
   - [[#tangle-via-org-mode][Tangle via Org Mode]]
   - [[#tangle-via-command-line][Tangle via Command Line]]
   - [[#automatic-tangling][Automatic Tangling]]
   - [[#add-the-following-line-into-emacs][Add the following line into =~/.emacs=]]
   - [[#install-icons][Install icons]]
 - [[#package-management][Package Management]]
   - [[#package-init][package init]]
   - [[#use-package][use-package]]
   - [[#install-packages-manually][install packages manually]]
 - [[#basic-ui][Basic UI]]
   - [[#about-me][About Me]]
   - [[#basic][Basic]]
   - [[#speed-bar][Speed Bar]]
   - [[#font][Font]]
   - [[#keys][Keys]]
   - [[#customized-util-functions--bindings][Customized Util Functions & Bindings]]
   - [[#emacs-default-auto-save][emacs default auto save]]
   - [[#auto-save][Auto Save]]
   - [[#misc][Misc]]
 - [[#evil][evil]]
   - [[#init][init]]
   - [[#evil-collection][evil-collection]]
 - [[#more-ui][More UI]]
   - [[#doom-modeline][doom-modeline]]
   - [[#doom-theme][doom-theme]]
   - [[#line-number][Line Number]]
   - [[#parenthesis][parenthesis]]
   - [[#rainbow-delimiters][rainbow-delimiters]]
 - [[#which-key][which-key]]
 - [[#ivy--counsel][ivy & counsel]]
   - [[#init-1][init]]
   - [[#ivy-minibuffer-key-bindings][ivy minibuffer key bindings]]
   - [[#saving-the-current-completion-session-to-a-buffer][saving the current completion session to a buffer]]
 - [[#helpful][helpful]]
 - [[#org-mode][org-mode]]
   - [[#init-2][init]]
   - [[#add-agenda-files-into-emacs][add agenda files into =~/.emacs=]]
   - [[#org-mode-hook][org-mode-hook]]
   - [[#agenda-hook][agenda-hook]]
   - [[#custom-agenda-commands][custom agenda commands]]
   - [[#keyword-faces][Keyword Faces]]
   - [[#deadline-warning-days][Deadline Warning Days]]
   - [[#use-toc-org-to-automatically-generate-a-table-of-contents-for-org-files][Use toc-org to automatically generate a table of contents for Org files.]]
 - [[#text-mode][text-mode]]
   - [[#auto-fill][Auto Fill]]
   - [[#pro-file][Pro File]]
 - [[#helm][helm]]
   - [[#setup-helm][Setup helm]]
   - [[#setup-projectile][Setup projectile]]
 - [[#cc-mode][cc-mode]]
 - [[#cedet][cedet]]
 - [[#cmake][cmake]]
 - [[#company][company]]
   - [[#init-3][init]]
   - [[#company-quickhelp][company-quickhelp]]
   - [[#misc-1][misc]]
   - [[#company-c-headers][company-c-headers]]
 - [[#dired][dired]]
   - [[#key-binding][key binding]]
   - [[#listing-parameters][Listing Parameters]]
 - [[#flycheck][flycheck]]
   - [[#functions][functions]]
 - [[#folding][Folding]]
   - [[#main-code][Main Code]]
   - [[#key-binding-1][Key Binding]]
   - [[#example][Example]]
   - [[#test][Test]]
   - [[#todo][Todo]]
 - [[#graphviz-dot-mode][Graphviz Dot Mode]]
 - [[#html][html]]
   - [[#web-mode][web-mode]]
 - [[#imenu][imenu]]
 - [[#java][java]]
 - [[#js][js]]
   - [[#node-modules-path-setup][node-modules-path-setup]]
   - [[#js-mode][js-mode]]
   - [[#js2-mode][js2-mode]]
   - [[#js3-mode][js3-mode]]
   - [[#json-mode][json-mode]]
 - [[#jump-avy][jump (avy)]]
 - [[#lisp][lisp]]
   - [[#paredit][paredit]]
   - [[#clojure][clojure]]
 - [[#outline][outline]]
 - [[#python][python]]
 - [[#shell][shell]]
   - [[#sh-mode][sh mode]]
   - [[#shell-mode][shell mode]]
   - [[#term-mode][term mode]]
   - [[#tm-function][tm function]]
   - [[#sh-function][sh function]]
 - [[#speedbar][speedbar]]
 - [[#spell][spell]]
 - [[#tramp][tramp]]
 - [[#prettier][prettier]]
 - [[#plantuml][plantuml]]
 - [[#list][List]]
   - [[#read-a-list-of-people-with-nice-emacs-config-files][read a list of people with nice emacs config files]]
   - [[#toc-org][toc-org]]
   - [[#magit][magit]]
 - [[#license][License]]

* Introduction
:PROPERTIES:
:header-args: :tangle no
:END:
This is an Emacs configuration file written in Org-mode. It is adapted
from Lars Tveito's excellent [[https://github.com/larstvei/dot-emacs/blob/master/init.org][config file]] and Tianxiang Xiong's [[https://github.com/xiongtx/.emacs.d/blob/master/init.org][config]]
on GitHub.
** other reference
- https://github.com/daviwil/emacs-from-scratch
* Dotemacs Path
** Define =cf-path=
#+BEGIN_SRC emacs-lisp
(defvar cf-dotemacs-home (file-name-directory load-file-name))

(defun cf-path (path)
  (expand-file-name path cf-dotemacs-home))
#+END_SRC
** Extra load path
- updated from
  https://github.com/redguardtoo/emacs.d/blob/master/init.el
#+begin_src emacs-lisp
(defun my-add-site-dir (site-dir)
  "Add a directory into `load-path'."
  (setq load-path
        (append
         (delq nil
               (mapcar (lambda (dir)
                         (unless (string-match-p "^\\." dir)
                           (expand-file-name dir site-dir)))
                       (directory-files site-dir)))
         load-path)))
(my-add-site-dir (cf-path "site"))
#+end_src
* How to Install
After cloning from [[https://github.com/xiongtx/.emacs.d][GitHub]], there is no =init.el= file, only an
=init.org= file (this file). To produce an =init.el= file, either:
** Tangle via Org Mode
Open =init.org= and call =M-x org-babel-tangle=, which extracts code
blocks from the current file into =init.el=
** Tangle via Command Line
#+BEGIN_SRC sh :tangle no
$ ./tangle.sh
#+END_SRC
or
#+BEGIN_SRC sh :tangle no
$ emacs --batch \
        --eval "(require 'ob-tangle)" \
        --eval "(org-babel-tangle-file \"./init.org\")"
#+END_SRC
** Automatic Tangling
To avoid having to tangle manually each time a change is made, we can
add a function to ~after-save-hook~ to tangle the =init.org= after
saving.
#+BEGIN_SRC emacs-lisp
(defun cf-tangle-init-file ()
  "Tangle the current buffer if it is the init.org file."
  (when (equal (buffer-file-name) (cf-path "init.org"))
    (org-babel-tangle)))

(add-hook 'after-save-hook 'cf-tangle-init-file)
#+END_SRC
** Add the following line into =~/.emacs=
#+BEGIN_SRC emacs-lisp :tangle no
(load "/path/to/init.el")
#+END_SRC
** Install icons
Run M-x all-the-icons-install-fonts
* Package Management
** package init
#+begin_src emacs-lisp
(require 'package)
(setq package-archives
      '(
        ;; ("cf-melpa" . ,(cf-path "../cf-melpa/packages"))
        ;; ("melpa-stable" . "https://stable.melpa.org/packages/")
        ("melpa" . "https://melpa.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ;; ("elpa" . "https://elpa.gnu.org/packages/")
        ;; ("marmalade" . "https://marmalade-repo.org/packages/")
        ))
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+end_src
** use-package
https://github.com/jwiegley/use-package
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
;; make sure packages are installed
(setq use-package-always-ensure t)
#+end_src
** install packages manually
#+begin_src emacs-lisp :tangle no
;; https://github.com/melpa/melpa/issues/7238
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
(package-refresh-contents nil)
(package-install 'lsp-mode)
#+end_src
* Basic UI
** About Me
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'user-full-name "Chunfeng Dai")
;; (customize-set-variable 'user-mail-address "")
#+END_SRC
** Basic
#+begin_src emacs-lisp
(load-theme 'wombat)
(setq inhibit-startup-message t)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(menu-bar-mode -1)
(set-fringe-mode 10)
(setq visible-bell t)

;; highlight current line
(global-hl-line-mode t)
(if (display-graphic-p)
    (set-face-background hl-line-face "grey20"))

(setq default-fill-column 70)

(setq-default scroll-margin 3
              scroll-conservatively 10000)

;; frame title
(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b"))))

;; frame
(when (display-graphic-p)
  (add-to-list 'default-frame-alist '(height . 42))
  (add-to-list 'default-frame-alist '(width . 80))
  (add-to-list 'default-frame-alist '(left . 650))
  (add-to-list 'default-frame-alist '(top . 100)))

(setq-default indent-tabs-mode nil)
(setq default-tab-width 8)
#+end_src
** Speed Bar
#+BEGIN_SRC emacs-lisp
(add-hook
 'speedbar-load-hook
 '(lambda ()
    (add-to-list 'speedbar-frame-parameters '(width . 35))
    (setq speedbar-show-unknown-files t)
    (display-line-numbers-mode 0)))
#+END_SRC
** Font
:PROPERTIES:
:header-args: :tangle no
:END:
*** Font Lock
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC
*** Default Font
#+BEGIN_SRC emacs-lisp
(cond
 ;; windows
 ((string-equal system-type "windows-nt")
  (progn
    (set-default-font "Consolas:pixelsize=14:antialias=subpixel")
    (set-fontset-font "fontset-default"
		      'han '("Microsoft Yahei" . "unicode-bmp"))
    (add-to-list 'default-frame-alist
		 '(font . "Consolas:pixelsize=14:antialias=subpixel"))))
 ((string-equal system-type "darwin")
  (progn
    (setq default-directory "~/")
    (if (display-graphic-p)
        (set-fontset-font
         t 'han (font-spec :name "Songti SC")))))
 ;; linux
 ((string-equal system-type "gnu/linux")))
#+END_SRC
** Keys
*** switch C-c & C-g
#+BEGIN_SRC emacs-lisp
(keyboard-translate ?\C-c ?\C-g)
(keyboard-translate ?\C-g ?\C-c)
#+END_SRC
*** Set Key Bindings Function
#+BEGIN_SRC emacs-lisp
(defun cf-set-key-bindings (action bind-list &optional map)
  "Set key bindings. 'bind-list' is 2-D list."
  (dolist (pair bind-list)
    (if (null map)
	(funcall action (eval `(kbd ,(nth 0 pair))) (nth 1 pair))
      (funcall action map (eval `(kbd ,(nth 0 pair))) (nth 1 pair)))))
#+END_SRC
*** General Keys
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(
   ("<f7>" speedbar-get-focus)
   ("C-x C-o" other-window)
   ("<M-tab>" other-frame)
   ("M-q" fill-region)
   ("M-s" ispell-region)
   ("M-/" undo)
   ("C-?" help-command)
   ("C-x f" find-file)
   ("C-x g" goto-line)
   ("C-x b" list-buffers)
   ("C-c C-c" comment-or-uncomment-region)
   ))
#+END_SRC
** Customized Util Functions & Bindings
*** Find Map of Key Binding
Find a key binding is in which map. From [[http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs][stackoverflow]]
#+BEGIN_SRC emacs-lisp
(defun cf-overlay-key-binding (key)
  "Keymaps can also be attached to overlays, like yasnippet.
   From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (mapcar (lambda (keymap) (lookup-key keymap key))
          (cl-remove-if-not
           #'keymapp
           (mapcar (lambda (overlay)
                     (overlay-get overlay 'keymap))
                   (overlays-at (point))))))

(defun cf-find-kbd (key)
  "From: http://stackoverflow.com/questions/18801018/how-to-find-in-which-map-a-key-binding-is-from-programatically-in-emacs"
  (interactive "kInput key: ")
  (message "%s"
   (list
    (cf-overlay-key-binding key)
    (minor-mode-key-binding key)
    (local-key-binding key)
    (global-key-binding key))))
#+END_SRC
*** Dos to Unix
From [[http://www.emacswiki.org/emacs/DosToUnix][emacswiki]].
#+BEGIN_SRC emacs-lisp
(defun cf-dos2unix ()
  "From: http://www.emacswiki.org/emacs/DosToUnix
Not exactly but it's easier to remember"
  (interactive)
  (set-buffer-file-coding-system 'unix 't))
#+END_SRC
*** Path Related
#+BEGIN_SRC emacs-lisp
(defun cf-get-path ()
  ""
  (interactive)
  (let ((path
         (or buffer-file-name default-directory)))
    (message path)
    path))

(defun cf-copy-path ()
  ""
  (interactive)
  (let ((path (cf-get-path)))
    (if path
        (kill-new path))))
#+END_SRC
*** Eval and Replace
From: http://emacsredux.com/blog/2013/06/21/eval-and-replace/
#+BEGIN_SRC emacs-lisp
(defun my/eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
#+END_SRC
*** Revert All Buffers
From: http://blog.plover.com/prog/revert-all.html
#+BEGIN_SRC emacs-lisp
(defun cf-revert-all-buffers ()
  "Refreshes all open buffers from their respective files"
  (interactive)
  (let* ((list (buffer-list))
         (buffer (car list)))
    (while buffer
      (when (and (buffer-file-name buffer)
                 (not (buffer-modified-p buffer)))
        (set-buffer buffer)
        (revert-buffer t t t))
      (setq list (cdr list))
      (setq buffer (car list))))
  (message "Refreshed open files"))
#+END_SRC
*** Open Webstorm
#+BEGIN_SRC emacs-lisp
(defun cf-run-cmd-on-current-file (command)
  "run a command on the current file"
  (shell-command
   (format "open -a %s %s" command
           (shell-quote-argument (buffer-file-name)))))

(defun cf-open-webstorm ()
  (interactive)
  (cf-run-cmd-on-current-file "webstorm"))

;; (cf-set-key-bindings 'global-set-key '(("C-<f9>" cf-open-webstorm)))
#+END_SRC
*** idle
- ref: https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-utils.el
#+begin_src emacs-lisp
(defvar my-disable-idle-timer nil
  "Function passed to `my-run-with-idle-timer' is run immediately.")

(defun my-run-with-idle-timer (seconds func)
  "After SECONDS, run function FUNC once."
  (cond
   (my-disable-idle-timer
    (funcall func))
   (t
    (run-with-idle-timer seconds nil func))))
#+end_src
** emacs default auto save
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/17210/how-to-place-all-auto-save-files-in-a-directory
(setq auto-save-file-name-transforms
  `((".*" "~/.emacs-saves/" t)))
#+end_src
** Auto Save
- refs
  - https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-misc.el
  - https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-autoload.el
#+begin_src emacs-lisp
(defun setup-auto-save ()
  (autoload 'auto-save-enable "auto-save" "" t)
  (with-eval-after-load 'auto-save
    (push 'my-file-too-big-p auto-save-exclude)
    (push 'my-check-major-mode-for-auto-save auto-save-exclude)
    (setq auto-save-idle 1)
    (setq auto-save-slient t))
  (my-run-with-idle-timer 1 #'auto-save-enable))
(setup-auto-save)
#+end_src
** Misc
*** Mac Key
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  ;; windows
  (progn
    ))
 ((string-equal system-type "darwin")
  ;; mac os x
  (progn
    (setq mac-option-key-is-meta nil)
    (setq mac-command-key-is-meta t)
    ;;(setq mac-command-modifier 'meta)
    ;;(setq mac-option-modifier nil)
    ;; (setenv "NODE_NO_READLINE" "1")
    ;; (exec-path-from-shell-initialize)
    ))
 ((string-equal system-type "gnu/linux")
  (message "linux")
  (progn
    (defconst cf-system-include-dirs nil))))
#+END_SRC
*** Backup Files
#+BEGIN_SRC emacs-lisp
(setq-default make-backup-files nil)
#+END_SRC
*** Narrow
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC
*** Delete Selection Mode
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
*** Sentence End Double Space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Uniquify Buffer Name
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
*** Diff
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq diff-switches "-u")
#+END_SRC
*** Save Place
#+BEGIN_SRC emacs-lisp
(setq save-place-file (concat user-emacs-directory "places"))
#+END_SRC
*** Daemon Server
#+BEGIN_SRC emacs-lisp
(setq server-name "emacs-server")
(server-start)
#+END_SRC
*** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(if (package-installed-p 'exec-path-from-shell)
    (progn
     (require 'exec-path-from-shell)
     (cond
      ((string-equal system-type "windows-nt")
       ;; windows
       (progn
         (exec-path-from-shell-initialize)))
      ((string-equal system-type "darwin")
       ;; mac os x
       (progn
         (exec-path-from-shell-initialize)))))
  (message "exec-path-from-shell not installed"))
#+END_SRC
*** Default major mode
#+BEGIN_SRC emacs-lisp
(setq default-major-mode 'text-mode)
#+END_SRC
*** auto reload
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
*** electric pair
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(defun my-inhibit-electric-pair (char)
  (minibufferp))
(setq electric-pair-inhibit-predicate #'my-inhibit-electric-pair)
#+END_SRC
* evil
- github: https://github.com/emacs-evil/evil
- doc: https://evil.readthedocs.io/en/latest/index.html
** init
#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-shift-width 2)
  :config
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h")
    'evil-delete-backward-char-and-join)
  (define-key evil-replace-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-replace-state-map (kbd "C-h")
    'evil-delete-backward-char-and-join)
  (define-key evil-insert-state-map (kbd "C-n") nil)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src
** evil-collection
https://github.com/emacs-evil/evil-collection
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src
* More UI
** doom-modeline
https://github.com/seagle0128/doom-modeline
#+begin_src emacs-lisp
;; Install icons for doom
;; Run M-x all-the-icons-install-fonts to install
(use-package all-the-icons
  :if (display-graphic-p))

(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :custom
  ((doom-modeline-height 15)
   ))
#+end_src
** doom-theme
#+begin_src emacs-lisp
(use-package doom-themes
  :init (load-theme 'doom-vibrant t))
#+end_src
** Line Number
#+begin_src emacs-lisp
(global-display-line-numbers-mode)
(setq display-line-numbers-type 'visual)
(dolist (mode '(org-mode-hook
                shell-mode-hook
                term-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
** parenthesis
#+begin_src emacs-lisp
(show-paren-mode)
(setq show-paren-style 'mixed)
#+end_src
** rainbow-delimiters
https://github.com/Fanael/rainbow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
* which-key
https://github.com/justbur/emacs-which-key
#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.6))
#+end_src
* ivy & counsel
- https://github.com/abo-abo/swiper
- https://oremacs.com/swiper/
- https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html
** init
#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line) ; default M-n
         ("C-k" . ivy-previous-line) ; default M-p
         ("C-f" . ivy-scroll-up-command) ; default C-v
         ("C-b" . ivy-scroll-down-command) ; default M-v
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config (ivy-mode 1))

(use-package ivy-rich
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x C-b" . counsel-ibuffer)
         ("C-x b" . counsel-recentf)
         ("C-x C-f" . counsel-find-file)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)))
#+end_src
** ivy minibuffer key bindings
|-------+-------------------------+--------------------------------------------|
| M-<   | ivy-beginning-of-buffer |                                            |
| M->   | ivy-end-of-buffer       |                                            |
| RET   | ivy-done                | calls the default action                   |
| C-M-m | ivy-call                | calls the default action, keeps ivy open   |
| M-o   | ivy-dispatching-done    | displays available actions                 |
| C-M-o | ivy-dispatching-call    | displays available actions, keeps ivy open |
|       | ivy-resume              | restart ivy before last action             |
|-------+-------------------------+--------------------------------------------|
** saving the current completion session to a buffer
|---------+-----------------------+----------------------------------------------------|
| C-c C-o | ivy-occur             | save candidates to a buffer                        |
| RET     | ivy-occur-press       | call the current action on candidate               |
| mouse-1 | ivy-occur-click       |                                                    |
| j       | next-line             |                                                    |
| k       | previous-line         |                                                    |
| a       | ivy-occur-read-action | read an action and make it current for this buffer |
| o       | ivy-occur-dispatch    |                                                    |
| q       | quit-window           |                                                    |
|---------+-----------------------+----------------------------------------------------|
* helpful
#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+end_src
* org-mode
** init
#+BEGIN_SRC emacs-lisp
(require 'org-install)
(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
#+END_SRC
** add agenda files into =~/.emacs=
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-files
      '("~/path/to/todo/todo.org"))

(setq org-agenda-tetra
      "~/path/to/todo/tetra.org")
#+END_SRC
** org-mode-hook
#+BEGIN_SRC emacs-lisp
(defun cf-org-mode-hook-func ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; "C-c C-b" org-backward-heading-same-level
     ;; "C-c C-f" org-forward-heading-same-level
     ;; "C-c C-n" outline-next-visible-heading
     ("C-c C-p" outline-previous-visible-heading)
     ;; "C-c C-j" org-goto

     ;; ("M-<left>" org-metaleft)
     ;; ("M-<righ>" org-metaright)
     ;; ("M-<up>" org-metaup)
     ;; ("M-<down>" org-metadown)

     ;; ("M-S-<left>" org-shiftmetaleft)
     ;; ("M-S-<right>" org-shiftmetaright)
     ;; ("M-S-<up>" org-shiftmetaup)
     ;; ("M-S-<down>" org-shiftmetadown)

     ;; "M-h" org-mark-element

     ;; ("C-c C-f" org-kill-note-or-show-branches) ;; used to be 'C-c C-k'

     ("C-<tab>" org-cycle)
     ("C-S-<tab>" org-shifttab)
     ("C-c RET" nil)

     ;; ("C-S-i" org-table-previous-field)
     ;; ("M-S-RET" org-table-wrap-region)

     ;; ("C-c C-x C-p" org-preview-latex-fragment)

     ;; ("C-c [" nil) ;; org-agenda-file-to-front
     ;; ("C-c ]" nil) ;; org-remove-file
     ))
  ;; (cf-set-key-bindings
  ;;  'define-key
  ;;  '(
  ;;    ("C-M-h" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-day 1))))
  ;;    ("C-M-l" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-day 1))))
  ;;    ("C-M-k" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-week 1))))
  ;;    ("C-M-j" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-week 1))))
  ;;    ("C-M-S-h" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-backward-month 1))))
  ;;    ("C-M-S-l" (lambda () (interactive)
  ;;               (org-eval-in-calendar '(calendar-forward-month 1))))
  ;;    )
  ;; org-read-date-minibuffer-local-map)
  (org-indent-mode t)
  (flyspell-mode-off)
  (setq org-src-fontify-natively t)
  (setq org-edit-src-content-indentation 0)
  ;; (setq org-infojs-options cf-default-org-infojs-options)
  (setq org-export-html-use-infojs t) ; alternative: when-configured, nil
  (setq org-latex-preview-ltxpng-directory "/tmp/ltxpng/")
  )
(add-hook 'org-mode-hook 'cf-org-mode-hook-func)
#+END_SRC
** agenda-hook
#+BEGIN_SRC emacs-lisp
(defun cf-org-agenda-mode-hook-func ()
  (cf-set-key-bindings
   'define-key
   '(
     ("j" org-agenda-next-line)
     ("k" org-agenda-previous-line)
     ("J" org-agenda-next-item)
     ("K" org-agenda-previous-item)
     ("g" org-agenda-goto-date)
     ("G" org-agenda-clock-goto)
     )
   org-agenda-mode-map))
(add-hook 'org-agenda-mode-hook 'cf-org-agenda-mode-hook-func)
#+END_SRC
** custom agenda commands
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("d" "Daily Agenda and All TODOs"
         ((agenda "" ((org-agenda-ndays 1)))
          (alltodo ""
                   ((org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "HOLD" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))
          (alltodo ""
                   ((org-agenda-skip-function
                     '(or (org-agenda-skip-entry-if 'scheduled 'deadline)
                          (org-agenda-skip-entry-if 'todo '("HOLD"))))
                    (org-agenda-overriding-header "Todo Tasks without time:"))))
         ;; ((org-agenda-compact-blocks t))
         )
        ("h" "All Holds"
         ((alltodo ""
                   ((org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "PROG" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))))
        ("t" "Tetrascience"
         ((agenda ""
                  ((org-agenda-files `(,org-agenda-tetra))
                   (org-agenda-ndays 1)))
          (alltodo ""
                   ((org-agenda-files `(,org-agenda-tetra))
                    (org-agenda-skip-function
                     '(org-agenda-skip-entry-if
                       'todo '("TODO" "HOLD" "MISS")))
                    (org-agenda-overriding-header "In Progress Tasks:")))
          (alltodo ""
                   ((org-agenda-files `(,org-agenda-tetra))
                    (org-agenda-skip-function
                     '(or (org-agenda-skip-entry-if 'scheduled 'deadline)
                          (org-agenda-skip-entry-if 'todo '("HOLD"))))
                    (org-agenda-overriding-header "Todo Tasks without time:")))))))
#+END_SRC
** Todo Keyword Faces
#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      '(("TODO" . org-warning)
        ("IN-PROGRESS" . "yellow")
        ("PROG" . "yellow")
        ("PROGRESS" . "yellow")
        ("DONE" . "green")
        ("HOLD" . "red")
        ("CANCELLED" . "purple1")))
#+END_SRC
** Deadline Warning Days
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 10)
#+END_SRC
** Use toc-org to automatically generate a table of contents for Org files.
#+BEGIN_SRC emacs-lisp
(defun cf-setup-toc-org ()
  (add-hook 'org-mode-hook #'toc-org-enable))

(if (package-installed-p 'toc-org)
    (cf-setup-toc-org)
  (message "toc-org not installed"))
#+END_SRC
* text-mode
** Auto Fill
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
* helm
- http://tuhdo.github.io/helm-intro.html
- http://tuhdo.github.io/helm-projectile.html
- https://github.com/bbatsov/projectile
** Setup helm
#+BEGIN_SRC emacs-lisp
(defun cf-setup-helm ()
  (require 'helm)
  (require 'helm-config)

  ;; keys
  (cf-set-key-bindings
   'global-set-key
   '(
     ("M-y" helm-show-kill-ring)
     ;; ("C-x C-h C-p" helm-projectile)
     ("C-x C-p" helm-projectile)
     ("C-x C-d" helm-projectile-find-dir)
     ("C-x C-m" helm-semantic-or-imenu)
     ("C-x C-r" helm-resume)
     ("C-x C-h C-o" helm-occur)
     ("C-x C-h C-p" helm-projectile-switch-project)
     ("C-x C-h C-r" helm-resume)
     ("C-x C-h C-m" helm-all-mark-rings)
     ("C-x C-h C-g" helm-projectile-ag)
     ("C-x C-h C-k" helm-projectile-grep)
     ("C-x C-h C-a" helm-do-ag)
     ))

  ;; general
  ;; open helm buffer inside current window
  (setq helm-split-window-in-side-p t)
  ;; (setq helm-move-to-line-cycle-in-source t)
  ;; M-x
  (setq helm-M-x-fuzzy-match t)
  ;; Mini
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t)
  ;; imenu
  (setq helm-semantic-fuzzy-match t
        helm-imenu-fuzzy-match    t)
  (setq helm-ff-file-name-history-use-recentf t)
  ;; (helm-autoresize-mode t)
  ;; ;; 40% of current frame height
  ;; (setq helm-autoresize-max-height 40)
  ;; (setq helm-ff-search-library-in-sexp t)
  ;; (setq helm-scroll-amount 8)

  (helm-mode 1)

  (defun cf-bind-helm ()
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     minibuffer-local-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-generic-files-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-find-files-map)
    (cf-set-key-bindings
     'define-key
     '(("C-b" helm-previous-page)
       ("C-f" helm-next-page))
     helm-read-file-map)
    (cf-set-key-bindings
     'define-key
     '(
       ;; C-j helm-execute-persistent-action
       ;; C-] helm-toggle-buffers-details
       ("C-M-b" helm-scroll-other-window-down)
       ("C-b" helm-previous-page)
       ("C-f" helm-next-page)
       ("C-t" helm-toggle-visible-mark)
       )
     helm-map))
  (cf-bind-helm)

  ;; (setq helm-grep-default-command
  ;;       "ack-grep -Hn --color --smart-case --no-group %e %p %f"
  ;;       helm-grep-default-recurse-command
  ;;       "ack-grep -H --color --smart-case --no-group %e %p %f")
  )

(if (and (package-installed-p 'helm-core)
         (package-installed-p 'helm)
         (package-installed-p 'async))
    (cf-setup-helm)
  (message "helm-core, helm or async not installed"))
#+END_SRC
** Setup projectile
#+BEGIN_SRC emacs-lisp
(defun cf-setup-projectile ()
  (projectile-global-mode)
  (setq projectile-find-dir-includes-top-level t)
  (setq projectile-completion-system 'helm)
  (setq projectile-file-exists-remote-cache-expire nil)
  ;; (setq helm-projectile-fuzzy-match nil)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
  (setq helm-buffers-truncate-lines nil)
  ;; (require 'helm-projectile)
  (condition-case nil
      (helm-projectile-on)
    (error nil))
  (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
  (cf-set-key-bindings
   'define-key
   '(
     ("C-f" projectile-find-file)
     ("C-h" helm-projectile)
     ("C-p" helm-projectile-switch-project)
     ("C-g" helm-projectile-find-file-dwim))
   projectile-command-map))

(if (and (package-installed-p 'projectile)
         (package-installed-p 'helm-projectile))
    (cf-setup-projectile)
  (message "projectile or helm-projectile not installed"))
#+END_SRC
* cc-mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.vs$" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.fs$" . c++-mode))
(defun cf-semantic-ia-fast-jump-back ()
  "zz from: http://emacser.com/cedet.htm"
  (interactive)
  (if (ring-empty-p (oref semantic-mru-bookmark-ring ring))
      (error "Semantic Bookmark ring is currently empty"))
  (let* ((ring (oref semantic-mru-bookmark-ring ring))
         (alist (semantic-mrub-ring-to-assoc-list ring))
         (first (cdr (car alist))))
    (if (semantic-equivalent-tag-p (oref first tag)
                                   (semantic-current-tag))
        (setq first (cdr (car (cdr alist)))))
    (semantic-mrub-switch-tags first)))
(c-add-style
 "chunfeng-c-style"
 '("gnu"
   (c-basic-offset . 4)
   (c-offsets-alist
    .
    ((innamespace . 0)
     (arglist-intro . 4)
     (arglist-cont-nonempty . 4)
     (arglist-close . 4)
     ))))
;;(setq c-default-style "chunfeng-c-style")
(defun cf-init-c ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; ("M-l" c-forward-into-nomenclature)
     ;; ("M-h" c-backward-into-nomenclature)
     ;; ("C-M-h" backward-sexp)
     ;; ("C-M-b" c-mark-function)
     ;; ("C-c C-j" senator-next-tag)
     ;; ("C-c C-k" senator-previous-tag)
     ;; ("C-c C-t" semantic-analyze-proto-impl-toggle)
     ;; ("C-c C-f" semantic-ia-fast-jump)
     ;; ("C-c C-b" cf-semantic-ia-fast-jump-back)
     ("C-M-a" backward-paragraph)
     ("C-M-e" forward-paragraph)))
  ;; (semantic-mode)
  ;; (c-toggle-auto-state)
  (c-toggle-hungry-state 1))
(add-hook 'c-mode-hook 'cf-init-c)
(add-hook 'c++-mode-hook 'cf-init-c)
#+END_SRC
* cedet
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
;; cedet

;(cf-install-packages '(cedet))
;(require 'cedet)

(defconst cedet-home "~/.emacs.d/site-byte/cedet")
(defconst cedet-pro-home "~/.emacs.d/cedet-pro")

(setq byte-compile-warnings nil)

(defconst cf-user-include-dirs
  (list ".." "../frame" "../src" "../include"
	"../.." "../../frame" "../../src" "../../include"
	"../../.." "../../../frame" "../../../src" "../../../include"))

(defun cf-semantic-folding-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("C-c C-," semantic-tag-folding-fold-block)
     ("C-c C-." semantic-tag-folding-show-block)
     ("C-c C--" semantic-tag-folding-fold-all)
     ("C-c C-=" semantic-tag-folding-show-all)
     )
   semantic-tag-folding-mode-map))

(defun cf-semantic-tag-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("f" semantic-ia-fast-jump)
     ("b" cf-semantic-ia-fast-jump-back)
     )
   senator-prefix-map))

(defun cf-load-cedet ()
  ""
  (interactive)
  (add-to-list 'load-path (concat cedet-home "/common"))
  (require 'cedet)
  (require 'semantic-ia)
  (require 'semantic-gcc)
  ;;(load-file "~/.emacs.d/site-byte/cedet/common/cedet.el")
  (semantic-load-enable-code-helpers)
  (semantic-load-enable-minimum-features)
  ;;(semantic-load-enable-guady-code-helpers)
  ;;(semantic-load-enable-excessive-code-helpers)
  ;;(semantic-load-enable-semantic-debugging-helpers)
  (require 'semanticdb)
  (global-semanticdb-minor-mode 1)
  ;;(require 'semanticdb-global)
  ;;(semanticdb-enable-gnu-global-databases 'c-mode)
  ;;(semanticdb-enable-gnu-global-databases 'c++-mode)
  (global-ede-mode 1)
  (let ((include-dirs cf-user-include-dirs))
    (if (string-equal system-type "windows-nt")
	(setq include-dirs
	      (append include-dirs cf-system-include-dirs)))
    (mapc (lambda (dir)
	    (semantic-add-system-include dir 'c++-mode)
	    (semantic-add-system-include dir 'c-mode))
	  include-dirs))
  (require 'semantic-tag-folding nil 'noerror)
  (global-semantic-tag-folding-mode 1)
  (cf-semantic-folding-key-binding)
  (cf-semantic-tag-key-binding)
  (if (file-exists-p cedet-pro-home)
      (mapc 'load
            (directory-files cedet-pro-home t
                             "^[a-zA-Z0-9].*.el$"))))

;; (if (file-exists-p cedet-home)
;;     (cf-load-cedet))
#+END_SRC
* company
- [[http://company-mode.github.io/][company-mode]], a modular in-buffer completion framework for Emacs.
- user manual: http://company-mode.github.io/manual/index.html
- useful functions
  - company-show-location
  - comapny-show-doc-buffer (<f1>)
  - company-diag
  - company-other-backend
  - company-begin-backend
  - company-capf
  - company-yasnippet
- useful variables
  - company-backends
** init
#+BEGIN_SRC emacs-lisp
(defun cf-setup-company ()
  ;; Init
  (add-hook 'after-init-hook #'global-company-mode)
  ;; Reduce completion menu time delay to minimum.
  (customize-set-variable 'company-idle-delay 0)
  ;; key
  (with-eval-after-load 'company
    ;; select completion
    (cf-set-key-bindings
     'define-key
     '(
       ("C-n" company-select-next) ;; "M-n"
       ("C-p" company-select-previous) ;; "M-p"
       ;; ("<RET>" company-complete-selection)
       ;; ("<tab>" company-complete-common)
       )
     company-active-map)
    (cf-set-key-bindings
     'global-set-key
     '(
       ("C-n" company-complete) ;; "M-n"
       ))
    )
  ;; Show quick-access numbers of completion options.
  (customize-set-variable 'company-show-numbers t)
  ;; Align annotations.
  (customize-set-variable 'company-tooltip-align-annotations t)
  (customize-set-variable 'company-dabbrev-downcase nil))
(if (package-installed-p 'company)
    (cf-setup-company)
  (message "company mode not installed"))
#+END_SRC
** company-quickhelp
Use [[https://github.com/expez/company-quickhelp][company-quickhelp]], which shows a documentation pop-up during
=company-mode= completion.
#+BEGIN_SRC emacs-lisp :tangle no
(defun cf-setup-company-quickhelp ()
  (company-quickhelp-mode t)
  ;; Do not show pop-up automatically
  (customize-set-variable 'company-quickhelp-delay nil)
  ;; Define binding for showing pop-up manually in company-active-map instead of
  ;; company-quickhelp-mode-map; this activates it only when we want completion.
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "C-c h") #'company-quickhelp-manual-begin)))
(if (and (package-installed-p 'company)
         (package-installed-p 'company-quickhelp-mode))
    (cf-setup-company-quickhelp)
  (message "company or company-quickhelper not installed"))
#+END_SRC
** misc
There's also ~company-show-doc-buffer~, which is built into
~company-mode-map~, but the selections disappear when the doc buffer
appears (maybe it just doesn't play nice with =popwin=?). Furthermore,
it's easier to read the documentation when it's right next to the
candidate.
** company-c-headers
- https://github.com/randomphrase/company-c-headers
- This library enables the completion of C/C++ header file names using
  Company mode
#+BEGIN_SRC emacs-lisp
(defun cf-setup-company-c-headers ()
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-c-headers)))
(if (package-installed-p 'company-c-headers)
    (cf-setup-company-c-headers)
  (message "company-c-headers not installed"))
#+END_SRC
* dired
** key binding
#+BEGIN_SRC emacs-lisp
(defun cf-dired-key-binding ()
  (cf-set-key-bindings
   'define-key
   '(
     ("j" dired-next-line)
     ("k" dired-previous-line)
     ("r" revert-buffer)
     ("C-t" set-mark-command))
   dired-mode-map))
(add-hook 'dired-mode-hook 'cf-dired-key-binding)
#+END_SRC
** Listing Parameters
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alnoh")
(defun cf-set-ls (parameter)
  "Set ls parameter in dired mode"
  (interactive "s")
  (setq dired-listing-switches parameter))
#+END_SRC
* flycheck
#+BEGIN_SRC emacs-lisp
(defvar flycheck-global-modes)

(defun cf-setup-flycheck ()
  (require 'flycheck)
  (add-hook 'after-init-hook 'global-flycheck-mode)
  (setq flycheck-global-modes
        '(emacs-lisp-mode js-mode js2-mode json-mode web-mode))
  (setq-default flycheck-disabled-checkers
                '(emacs-lisp-checkdoc))
  ;; jsx setting
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlint)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
)

(if (package-installed-p 'flycheck)
    (cf-setup-flycheck)
  (message "flycheck not installed"))
#+END_SRC
** functions
- =flycheck-verify-setup= (=C-c ! v=): to check whether flycheck setup
  is complete
- (=C-c ! n=) & (=C-c ! p=): to jump back and forth between erroneous
  places
- (=C-c ! l=): to pop up a list of all errors in the current buffer
- =flycheck-select-checker=: to use this as the 1st for current buffer
- =flycheck-buffer= (=C-c ! c=): to check manually
- =[var]flycheck-checker=: checker used for current buffer
* Folding
** Main Code
#+BEGIN_SRC emacs-lisp
(setq default-label 'cycle-fold)

(defun goto-list (count depth)
  (condition-case ex
      (goto-char (scan-lists (point) count depth))
    (error
      (message "Error in goto-list: %s" ex)
      nil)))

(defun scan-lists-safe (from count depth &optional default)
  (condition-case ex
      (scan-lists from count depth)
    (error
      (message "Error in scan-lists: %s" ex)
      default)))

(defun get-bol (pos)
  (save-excursion (goto-char (or pos (point)))
                  (beginning-of-line)
                  (point)))

(defun get-eol (pos)
  (save-excursion (goto-char (or pos (point)))
                  (end-of-line)
                  (point)))

(defun my-filter (condp lst)
  (delq nil
        (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

(defun label->tag (label)
  (intern (concat "tag-" (symbol-name (or label default-label)))))

(defun create-overlay (start end &optional label val)
  (let ((o (make-overlay start end))
        (tag (label->tag label)))
    ;; (message "tag: %s" tag)
    (if val
        (overlay-put o tag val)
      (overlay-put o tag t))
    (overlay-put o 'evaporate t)
    (overlay-put o 'invisible t)
    (overlay-put o 'display `(:string "..."))
    (overlay-put
     o 'isearch-open-invisible
     (lambda (ov)
       (message "open invisible")
       (delete-overlay ov)))
    (overlay-put
     o 'isearch-open-invisible-temporary
     (lambda (ov invisible)
       (overlay-put ov 'invisible invisible)
       (overlay-put ov 'display (and invisible `(:string "...")))))
    o))

(defun get-overlays (start end &optional label val)
  (let ((tag (label->tag label))
        (os (overlays-in start end)))
    (if (null tag)
        os
      (my-filter (lambda (o)
                   (if (null val)
                       (overlay-get o tag)
                     (equal (overlay-get o tag) val)))
                 os))))

(defun delete-overlays (start end &optional label val)
  (dolist (o (get-overlays start end label val))
    (delete-overlay o)))

(defun cal-fold-region-at (&optional pos)
  (interactive)
  (let* ((start (or pos (point)))
         (eol (get-eol start))
         (end (scan-lists start 1 0)))
    (if (> (- end eol) 1)
        (list (cons :start eol)
              (cons :end (1- end))))))

(defun cal-fold-region-line (&optional pos)
  (interactive)
  (let* ((p (or pos (point)))
         (bol (get-bol p))
         (eol (get-eol p))
         (end (scan-lists-safe bol 1 0 (min (1+ bol) eol))))
    (while (< end eol)
      (setq end (scan-lists-safe end 1 0 (min (1+ end) eol))))
    (if (> end eol)
        (cal-fold-region-at (scan-lists end -1 0)))))

(defun current-fold-state (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (let* ((start (cdr (assoc :start range)))
               (end (cdr (assoc :end range)))
               (os (get-overlays start end)))
          ;; (message "%s %s %s" start end os)
          (if os
              (if (and (null (cdr os))
                       (equal start (overlay-start (car os)))
                       (equal end (overlay-end (car os))))
                  :folded
                :mis-folded)
            :unfolded))
      :no-fold)))

(defun fold-at (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-at pos)))
    (if range
        (create-overlay (cdr (assoc :start range))
                        (cdr (assoc :end range))))))

(defun fold-line (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (create-overlay (cdr (assoc :start range))
                        (cdr (assoc :end range))))))

(defun fold-at-end (&optional pos)
  (interactive)
  (save-excursion
    (goto-list -1 0)
    (fold-at (point))))

(defun unfold-line (&optional pos)
  (interactive)
  (let ((range (cal-fold-region-line pos)))
    (if range
        (delete-overlays (cdr (assoc :start range))
                         (cdr (assoc :end range))))))

(defun fold-children (&optional pos)
  (interactive)
  (save-excursion
    (let ((range (cal-fold-region-line pos)))
      (when range
        (goto-char (cdr (assoc :start range)))
        (while (goto-list 1 0)
          (fold-at-end))))))

(defun toggle-fold-line (&optional pos)
  (interactive)
  (let ((status (current-fold-state)))
    (cond
     ((eq status :no-fold) nil)
     ((eq status :unfolded) (fold-line pos))
     ((eq status :mis-folded)
      (unfold-line pos)
      (unless (eq last-command 'toggle-fold-line)
        (fold-line pos)))
     ((eq status :folded)
      (unfold-line pos)
      (fold-children pos))
     (t :default))))

(defun toggle-fold-all ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (if (and (eq last-command 'toggle-fold-all)
             (get-overlays (point-min) (point-max)))
        (delete-overlays (point-min) (point-max))
      (progn (delete-overlays (point-min) (point-max))
             (while (goto-list 1 0)
               (fold-at-end))))))
#+END_SRC
** Key Binding
#+BEGIN_SRC emacs-lisp
(cf-set-key-bindings
 'global-set-key
 '(("C-<tab>" toggle-fold-line)
   ("C-S-<tab>" toggle-fold-all)))
#+END_SRC
** Example
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
'(a b c
    (d
     e)
    (f g)
    (h
     (i j))
    ((k l
        (m n)
        (p q) (r s))
     o))
#+END_SRC
** Test
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(message "****************** start *******************")
(message "label->tag: %s" (label->tag 'test))
(message "label->tag === 'tag-test: %s" (eq (label->tag 'test) 'tag-test))
(message "delete-overlays: %s" (delete-overlays 1 100 'test))
(message "create-overlay: %s" (create-overlay 1 10 'test))
(message "get-overlays: %s" (get-overlays 1 100 'test))
(message "delete-overlays: %s" (delete-overlays 1 100 'test))
(message "get-overlays: %s" (get-overlays 1 100 'test))
(message "****************** end *******************")

(overlay-put o 'face `(:background "grey50"))
(overlay-put o 'face nil)
(overlay-put o 'display `(:string "(...)"))
(overlay-put o 'display nil)
#+END_SRC
** Todo
- minor mode
- 'helm-after-action-hook
- 'helm-after-persistent-action-hook
- 'occur-mode-find-occurrence-hook
- bug of [{\n},{\n},{\n}]
- lightweight-macro
* Graphviz Dot Mode
#+BEGIN_SRC emacs-lisp
(defun cf-graphviz-mode ()
  ""
  (setq graphviz-dot-indent-width 2)
  ;; (setq graphviz-dot-auto-indent-on-semi nil)
  )
(add-hook 'graphviz-dot-mode-hook 'cf-graphviz-mode)
#+END_SRC
* html
** web-mode
#+BEGIN_SRC emacs-lisp
(defun cf-web-mode-setup ()
  (add-to-list 'auto-mode-alist '("\\.jsx" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.hbs$" . web-mode))
  (defun cf-web-mode-func()
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-style-padding 2)
    (setq web-mode-script-padding 2)
    (setq web-mode-block-padding 0)
    (set-face-attribute 'web-mode-html-tag-face nil :foreground "SkyBlue1")
    (setq web-mode-enable-current-element-highlight t)
    (set-face-attribute 'web-mode-current-element-highlight-face nil :background "honeydew4")
    (setq web-mode-enable-current-column-highlight nil)
    (setq web-mode-enable-sexp-functions t)
    ;; (setq web-mode-enable-auto-quoting nil)
    ;; (setq web-mode-enable-auto-indentation nil)
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("C-t" nil)
       ;; ("M-t" nil)
       ;; ("M-t" web-mode-mark-and-expand)
       ;; ("C-c C-e C-c" web-mode-element-close)
       ;; ("C-c C-e C-/" web-mode-element-close)
       )
     web-mode-map))
  (add-hook 'web-mode-hook 'cf-web-mode-func))
(if (package-installed-p 'web-mode)
    (cf-web-mode-setup)
  (message "web-mode not installed"))
#+END_SRC
* imenu
#+BEGIN_SRC emacs-lisp
(setq imenu-auto-rescan nil)
#+END_SRC
* java
#+BEGIN_SRC emacs-lisp
(defun cf-java-func ()
  (setq c-basic-offset 2)
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; ("C-M-h" backward-sexp)
     ;; ("C-M-b" c-mark-function)
     ;; ("C-M-a" nil)
     ;; ("C-M-e" nil)
     ;; ("M-k" c-beginning-of-defun)
     ;; ("M-j" c-end-of-defun)
     ;; ("C-d" nil)
     ("C-c C-c" comment-or-uncomment-region)
     )))
(add-hook 'java-mode-hook 'cf-java-func)
#+END_SRC
* js
** node-modules-path-setup
From: https://github.com/codesuki/add-node-modules-path
#+BEGIN_SRC emacs-lisp
(defun cf-node-modules-path-setup ()
  (defvar add-node-modules-path-debug nil
    "Enable verbose output when non nil.")

  (defun add-node-modules-path ()
    "Search the current buffer's parent directories for `node_modules/.bin`.
If it's found, then add it to the `exec-path'."
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (path (and root
                      (expand-file-name "node_modules/.bin/" root))))
      (if root
          (progn
            (make-local-variable 'exec-path)
            (add-to-list 'exec-path path)
            (when add-node-modules-path-debug
              (message (concat "added " path  " to exec-path"))))
        (when add-node-modules-path-debug
          (message (concat "node_modules not found in " root))))))
  (eval-after-load 'js-mode
    '(add-hook 'js-mode-hook #'add-node-modules-path))
  (eval-after-load 'js2-mode
  '(add-hook 'js2-mode-hook #'add-node-modules-path))
  (eval-after-load 'web-mode
    '(add-hook 'web-mode-hook #'add-node-modules-path)))
(cf-node-modules-path-setup)
#+END_SRC
** js-mode
#+BEGIN_SRC emacs-lisp
(defun cf-js-setup ()
  (setq-default js-indent-level 2))
(cf-js-setup)
#+END_SRC
** js2-mode
#+BEGIN_SRC emacs-lisp
(defun cf-js2-setup ()
  ;; js2-mode-hide-comments
  ;; js2-mode-hide-element
  ;; js2-mode-hide-functions
  ;; js2-mode-hide-warnings-and-errors
  ;;
  ;; js2-mode-show-all
  ;; js2-mode-show-comments
  ;; js2-mode-show-element
  ;; js2-mode-show-functions
  ;; js2-mode-show-node
  ;;
  ;; js2-mode-toggle-element "C-c C-o"
  ;; js2-mode-toggle-hide-comments
  ;; js2-mode-toggle-hide-functions
  ;; js2-mode-toggle-warnings-and-errors
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
  (setq-default js-indent-level 2)
  ;; this will hide errors & warnings
  (setq-default js2-mode-show-parse-errors nil)
  (setq-default js2-mode-show-strict-warnings nil)
  (setq-default js2-bounce-indent-p t)
  ;; (setq-default js2-strict-inconsistent-return-warning nil)
  (defun cf-init-js ()
    ;; (electric-indent-mode -1)
    (cf-set-key-bindings
     'local-set-key
     '()))
  (add-hook 'js2-mode-hook 'cf-init-js))

(if (package-installed-p 'js2-mode)
    (cf-js2-setup)
  (message "js2-mode not installed"))
#+END_SRC
** js3-mode
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(defun cf-js3-setup ()
  (autoload 'js3-mode "js3-mode" nil t)
  (eval-after-load "js3-mode"
    (add-hook 'js3-mode-hook
              (lambda ()
                (setq ;; js3-auto-indent-p nil
                      js3-curly-indent-offset 0
                      js3-enter-indents-newline t
                      js3-expr-indent-offset 2
                      js3-indent-on-enter-key t
                      js3-lazy-commas t
                      js3-lazy-dots t
                      js3-lazy-operators t
                      js3-paren-indent-offset 2
                      js3-square-indent-offset 4)
                (auto-complete-mode 1))))
  (add-to-list 'auto-mode-alist '("\\.js$" . js3-mode)))
(if (package-installed-p 'js3-mode)
    (cf-js3-setup)
  (message "js3-mode not installed"))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
(defun cf-json-setup ())
(if (package-installed-p 'json-mode)
    (cf-json-setup)
  (message "json-mode not installed"))
#+END_SRC
* jump (avy)
#+BEGIN_SRC emacs-lisp
(defun cf-setup-avy ()
  (cf-set-key-bindings
   'global-set-key
   '(
     ("M-f" nil)

     ("M-f M-f" avy-goto-word-1)
     ("M-f M-g" avy-goto-word-0)

     ("M-f M-j" avy-goto-char-2)
     ("M-f M-k" avy-goto-char)

     ("M-f M-d" avy-goto-char-in-line)

     ("M-f M-l" avy-goto-line)
     )))

(if (package-installed-p 'avy)
    (cf-setup-avy)
  (message "avy not installed"))
#+END_SRC
* lisp
** paredit
#+BEGIN_SRC emacs-lisp :tangle no
(defun cf-paredit-setup ()

  (dolist (mode '(scheme emacs-lisp lisp clojure clojurescript))
    ;; (when (> (display-color-cells) 8)
    ;;   (font-lock-add-keywords (intern (concat (symbol-name mode) "-mode"))
    ;;                           '(("(\\|)" . 'esk-paren-face))))
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
              'paredit-mode))

  (defun cf-paredit-key ()
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("C-j" next-line)
       ;; ("C-k" previous-line)
       ;; ("C-f" paredit-kill)
       ;; ("C-n" paredit-newline)
       ;; ("C-d" nil)

       ;; ("C-M-b" nil)
       ;; ("C-M-f" nil)
       ;; ("C-M-h" paredit-backward)
       ;; ("C-M-l" paredit-forward)
       ;; ("C-M-j" paredit-forward-up)
       ;; ("C-M-k" paredit-backward-down)

       ;; ("(" nil)
       ;; (")" nil)
       ;; ("[" nil)
       ;; ("]" nil)
       ;; ("{" nil)
       ;; ("}" nil)
       ;; ("\"" nil)
       )
     paredit-mode-map))

  ;; (eval-after-load 'paredit '(cf-paredit-key))
  )

(if (package-installed-p 'paredit)
    (cf-paredit-setup)
  (message "paredit not installed"))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp :tangle no
(defun cf-clojure-mode-setup ()
  ;; (add-hook 'nrepl-mode-hook 'subword-mode)
  ;; (add-hook 'nrepl-mode-hook 'rainbow-delimiters-mode)

  (defun cf-clojure-match-next-def ()
    "Scans the buffer backwards for the next top-level definition.
Called by `imenu--generic-function'."
    (when (re-search-backward "^\\s *(def\\S *[ \n\t]+" nil t)
      (save-excursion
        (goto-char (match-end 0))
        (when (looking-at "#?\\^")
          (let (forward-sexp-function) ; using the built-in one
            (forward-sexp)))           ; skip the metadata
        (re-search-forward "[^ \n\t)]+"))))

  (defun cf-clojure-mode-func ()
    (cf-set-key-bindings
     'define-key
     '(
       ;; ("{" nil)
       ;; ("}" nil)
       )
     clojure-mode-map)
    (setq-local imenu-create-index-function
                (lambda ()
                  (imenu--generic-function
                   '((nil cf-clojure-match-next-def 0))))))
  (add-hook 'clojure-mode-hook 'cf-clojure-mode-func))

(if (package-installed-p 'clojure-mode)
    (cf-clojure-mode-setup)
  (message "clojure-mode not installed"))
#+END_SRC
* outline
#+BEGIN_SRC emacs-lisp
(setq outline-minor-mode-prefix (kbd "C-c C-o"))
(defun cf-outline-minor-mode ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ("C-c C-=" show-all)
     ("C-c C--" hide-body)
     ("C-c C-[" hide-subtree)
     ("C-c C-]" show-subtree)
     ("C-c C-," hide-entry)
     ("C-c C-." show-entry)
     ;; ("C-c C-j" outline-next-visible-heading)
     ;; ("C-c C-k" outline-previous-visible-heading)
     ;; ("C-c C-h" outline-backward-same-level)
     ;; ("C-c C-l" outline-forward-same-level)
     ;; ("C-c C-u" outline-up-heading)
     )
   )
  )
(add-hook 'outline-minor-mode-hook 'cf-outline-minor-mode)
#+END_SRC
* python
#+BEGIN_SRC emacs-lisp
(defun cf-python-setup ()
  (autoload 'python-mode "python-mode" "Python Mode." t)
  (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))

  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")

  (defun cf-init-python ()
    (cf-set-key-bindings
     'local-set-key
     '())
    (cf-set-key-bindings
     'define-key
     '(;; ("C-j" nil)
       ;; ("C-n" py-newline-and-indent)
       ;; ("C-m" nil)
       ;; ("C-M-h" nil)
       ;; ("C-M-b" py-mark-def-or-class)
       ;; ("M-j" py-forward-block-or-clause)
       ;; ("M-k" py-backward-block-or-clause)
       ;; ("C-M-j" py-forward-block-or-clause)
       ;; ("C-M-k" py-backward-block-or-clause)
       ;; ("C-M-a" nil)
       ;; ("C-M-e" nil)
       ;; ("C-c C-v" nil)
       ;; ("C-c C-x" nil)
       ;; ("C-c C-m" nil)
       ;; ("C-c C-v C-l" py-shift-right)
       ;; ("C-c C-v C-h" py-shift-left)
       ;; ("C-c C-i C-l" py-shift-right)
       ;; ("C-c C-i C-h" py-shift-left)
       ;; ("C-c C-x C-l" py-shift-block-or-clause-right)
       ;; ("C-c C-x C-h" py-shift-block-or-clause-left)
       )
     python-mode-map)
    ;; (subword-mode)
    (setq python-indent-offset 4)
    ;; (c-toggle-auto-state)
    (c-toggle-hungry-state 1)
    (highlight-indentation-mode)
    (highlight-indentation-current-column-mode)
    ;; (setq py-complete-function nil)
    (company-mode -1) ;; disable auto complete
    )
  (add-hook 'python-mode-hook 'cf-init-python))

;; https://www.seas.upenn.edu/~chaoliu/2017/09/01/python-programming-in-emacs/
(defun cf-jedi-setup ()
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook 'jedi:setup)
  (add-hook 'python-mode-hook 'jedi:ac-setup))

(if (package-installed-p 'python-mode)
    (cf-python-setup)
  (message "python-mode not installed"))
;; (if (package-installed-p 'company-jedi)
;;     (cf-jedi-setup)
;;   (message "company-jedi not installed"))
#+END_SRC
* shell
** sh mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/\\.bash_[^/]*\\'" . sh-mode))
#+END_SRC
** shell mode
#+BEGIN_SRC emacs-lisp
(defun cf-shell-mode-hook-func ()
  (cf-set-key-bindings
   'local-set-key
   '(
     ;; ("C-d" cf-shell-kill)
     ("C-M-l" nil)
     ;;("C-c h" comint-history-isearch-backward)
     ;;("M-s" comint-history-isearch-search)
     ("C-c h" comint-history-isearch-backward-regexp)

     ("M-n" comint-next-input)
     ("M-p" comint-previous-input)
     ("C-M-n" comint-next-matching-input-from-input)
     ("C-M-p" comint-previous-matching-input-from-input)

     ("C-c C-b" shell-backward-command)
     ("C-c C-f" shell-forward-command)
     ("C-c C-n" comint-next-prompt)
     ("C-c C-p" comint-previous-prompt)

     )
   ;;shell-mode-map
   )
  )
(add-hook 'shell-mode-hook 'cf-shell-mode-hook-func)
#+END_SRC
** term mode
#+BEGIN_SRC emacs-lisp
(defun cf-term-mode-hook-func ()
  (setq-local scroll-margin 0)
  (cf-set-key-bindings
   'local-set-key
   '(
     ))
  (cf-set-key-bindings
   'define-key
   '(("C-b" scroll-up-command)
     ("C-f" scroll-down)
     ("C-y" term-paste)
     ("s-v" term-paste)
     ("M-x" nil)
     ("C-u" universal-argument)
     ("C-c C-y" term-interrupt-subjob)
     )
   term-raw-map))
(add-hook 'term-mode-hook 'cf-term-mode-hook-func)
#+END_SRC
** tm function
#+BEGIN_SRC emacs-lisp
(defun tm ()
  "start-ansi-term"
  (interactive)
  (let (bf-name
        (sh-name "/bin/bash"))
    (if t ;;current-prefix-arg
        (setq bf-name
              (read-from-minibuffer "Buffer (*tm*): " bf-name)))
    (if (or (not bf-name)
            (= (length bf-name) 0))
        (setq bf-name "*tm*"))
    (setq bf-name (generate-new-buffer-name bf-name))
    (ansi-term sh-name)
    (rename-buffer bf-name)))
#+END_SRC
** sh function
#+BEGIN_SRC emacs-lisp
(defun sh ()
  "start-shell"
  (interactive)
  (let (bf-name)
    (setq bf-name
          (read-from-minibuffer "Buffer (*shell*): " bf-name))
    (if (or (not bf-name)
            (= (length bf-name) 0))
        (shell)
      (shell bf-name))))
#+END_SRC
* spell
#+BEGIN_SRC emacs-lisp
(setq-default ispell-program-name "aspell")
#+END_SRC
* tramp
#+BEGIN_SRC emacs-lisp :tangle no
(require 'tramp)
(setq tramp-default-method "scp")
;;(custom-set-variables '(tramp-verbose 6))
(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
#+END_SRC
* prettier
- https://github.com/prettier/prettier-emacs
- https://prettier.io/
#+BEGIN_SRC emacs-lisp
(defun cf-setup-prettier ()
  ;; (add-hook 'js2-mode-hook
  ;;           #'(lambda ()
  ;;               (if (executable-find "prettier")
  ;;                   (prettier-js-mode))))
  ;; (add-hook 'web-mode-hook
  ;;           #'(lambda ()
  ;;               (if (and (executable-find "prettier")
  ;;                        (buffer-file-name)
  ;;                        (string-match "\\.jsx?\\'" buffer-file-name))
  ;;                   (prettier-js-mode))))
  ;; (add-hook 'yaml-mode-hook
  ;;           #'(lambda ()
  ;;               (if (executable-find "prettier")
  ;;                   (prettier-js-mode))))
  (global-set-key [f8] 'prettier-js)
  )
(if (package-installed-p 'prettier-js)
    (cf-setup-prettier)
  (message "prettier-js not installed"))
#+END_SRC
* plantuml
#+begin_src emacs-lisp
;; use M-x plantuml-download-jar<RET> to download jar
;; use M-x plantuml-preview<RET> to preview
(defun cf-plantuml-setup ()
  (setq plantuml-jar-path "~/dev/lib/plantuml.jar")
  (setq plantuml-default-exec-mode 'jar)
  (add-to-list
   'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
  ;; add to org-mode
  (add-hook
   'org-mode-hook
   (lambda ()
     (add-to-list
      'org-src-lang-modes '("plantuml" . plantuml))))
  )
(if (package-installed-p 'plantuml-mode)
    (cf-plantuml-setup)
  (message "plantuml-mode not installed"))
#+end_src
* Todo List
** TODO read a list of people with nice emacs config files
- https://github.com/zamansky/emacs.dz
** TODO toc-org
- https://github.com/snosov1/toc-org
** TODO magit
* License
My Emacs configurations written in Org mode.

Copyright (c) 2013-2018 Chunfeng Dai

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
